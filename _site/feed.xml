<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NorthCity’s Blog</title>
    <description>在这里探索iOS的一切。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 30 Aug 2017 23:20:33 +0800</pubDate>
    <lastBuildDate>Wed, 30 Aug 2017 23:20:33 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>iOS项目中常用的“打补丁”技巧</title>
        <description>&lt;h1 id=&quot;ios项目中常用的打补丁技巧&quot;&gt;iOS项目中常用的“打补丁”技巧&lt;/h1&gt;

&lt;p&gt;嗯。。怎么开篇呢&lt;/p&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;(一个小时。。搓脚毛苦思中。。)&lt;/p&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;呵呵，你以为博主真的不知道怎么开篇么，这里花了一个小时的时间其实是另有深意的好么，我的套路就是这么湿！！，其实博主是为了阐述一个问题！就是如果只想了一个标题，内容却不知道怎么组织就会是这样的慢性尴尬症。就像我们做项目的时候经常脑袋一热，二话不说上来就撸代码。然后就发现框架不行，不够灵活无法扩展，功能缺失！然后在你准备调整架构的时候，产品经理就跳出来补上一刀——改需求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic1.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种绝望，我们都经历过！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产品经理常用必杀：&lt;/p&gt;

&lt;p&gt;『用户反应，按钮双击会有错误，所以你把整个项目有交互的控件都设置为不能双击吧，干巴爹』&lt;/p&gt;

&lt;p&gt;——&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;『这个输入框怎么能输入🐵🐵🐵这个呢，把所有的输入框都禁止输入乱七八糟的东西吧，么么哒』&lt;/p&gt;

&lt;p&gt;——这个是emoji，并没有这么乱七八糟。。&lt;/p&gt;

&lt;p&gt;『哦之前忘了定义，给所有的输入框都限制大数吧、给所有的页面都加上返回手势吧，给所有的……』&lt;/p&gt;

&lt;p&gt;『线上有几个页面暂时不需要了，能屏蔽掉么』&lt;/p&gt;

&lt;p&gt;。。。&lt;/p&gt;

&lt;p&gt;我能和产品探讨一下引力波的探测与广义相对论的必然联系么？老子弄死你丫的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我想项目新人几乎都遇到过这些坑吧，产品经理不专业在一般的公司里是常态，现在的互联网，一言不合就改需求，也是个常态。&lt;/p&gt;

&lt;p&gt;但是强大的猿类们，决不能屈服于这种常态，变态起来！！&lt;/p&gt;

&lt;p&gt;只要努力微笑，命运也会惧怕我的獠牙。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回到这次的主题——『打补丁』&lt;/p&gt;

&lt;p&gt;什么是打补丁呢，打补丁是使用针线在织物上辅以破布以缝补上，是民间伟大的传统手工艺之一。该技艺严谨精密，讲究施针，针法所达百余种，常见的有滚、铺、盖、戳等等，针脚整齐、掺色轻柔、虚实合度、变化丰富。一千多年来，逐步形成。。。诶，这老毛病就是改不了，总是喜欢一本正经的扯犊子~~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic6.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;博主要说的『打补丁』必然不是针线活！再次声明这里是技术博客，并非传统技艺授受中心！&lt;/p&gt;

&lt;p&gt;我们给一个东西打补丁，原因就两个字！破。&lt;/p&gt;

&lt;p&gt;所以我们给项目打补丁也是因为项目破了，就像遇到上面的整改需求，功能不完善了，功能缺失了我们就有了打补丁的必要了。&lt;/p&gt;

&lt;p&gt;在iOS中打补丁，我以修补时机为主分为两种打补丁的方式，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开发中的打补丁&lt;/li&gt;
  &lt;li&gt;线上的打补丁&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;开发中修补&quot;&gt;开发中修补&lt;/h2&gt;

&lt;p&gt;早知今日，何必当初。何出此感慨？假如开始项目的时候框架设计好一点，今天还会沦落到打补丁么？？但是耍流氓的敏捷开发、坑爹的开发周期、逆天的用户需求之下何来优秀的框架搭设啊？&lt;/p&gt;

&lt;p&gt;看着产品方案，我颤抖的小嘴刚要张开说『一个礼拜框架搭设，两个礼拜编码，应该…』然而老板拍拍你的肩膀『小伙子 这个周末弄出来，我以前也是做开发的，时间很充足哦，不许骗我喔~』，老板你确定你不是以前做PPT的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候的心情就跟刚看完《小时代》一样憋屈。所以开发中需要打补丁的状况太多了，改结构，重写，时间不够，所以只能打补丁了！&lt;/p&gt;

&lt;h3 id=&quot;aop&quot;&gt;AOP&lt;/h3&gt;

&lt;p&gt;当初学习JavaEE的时候接触了该理念，反正文邹邹的概念博主也不贴出来了，AOP就是面向切面编程的简称，说白了就是一个打补丁的编程方式！不侵入式地给一个方法添加代码。冠名之『 润物细无声の技能』，嘿嘿，有个片假名的标题，你们都兴奋了起来呢~~&lt;/p&gt;

&lt;p&gt;至于AOP的基本理念、适用场景等，各位看官就自行Wiki吧。什么竟然说博主其实也不懂什么是AOP！！！&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;知道什么是学霸么！就是举手投足高分拿下、信手拈来理论来辩、回眸一笑全是败将！不要怀疑！这就是博主，真学霸！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic9.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说了这么多，到底怎么用AOP方式给项目打补丁呢？&lt;/p&gt;

&lt;p&gt;我们来打个栗子吧！&lt;/p&gt;

&lt;p&gt;『只允许所有的控件的单击』&lt;/p&gt;

&lt;p&gt;一个项目中少说成百上千的控件，即使有些控件复用，项目中控件的数量也会几十上百的UI控件无法复用，那怎么把这几十上百的控件都禁止双击呢？&lt;/p&gt;

&lt;p&gt;我们知道UIView有个属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;@property(nonatomic,getter=isExclusiveTouch) BOOL       exclusiveTouch __TVOS_PROHIBITED;         // default is NO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个View设置&lt;code class=&quot;highlighter-rouge&quot;&gt;exclusiveTouch&lt;/code&gt;为YES的话，那么该View就会独占事件，就是当点击自己的时候，其他所有的View的事件都会被Block，并且当前的View也只能单次点击。利用这个特性我们就能把所有的控件的这个属性都设置为YES不就行了嘛。&lt;/p&gt;

&lt;p&gt;然后吭吃吭吃地给几十上百个控件都设置了该属性，看到都累，这样的方式打补丁，那万一产品又来了说不要禁止双击呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic10.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你这不是在给项目打补丁，是在打自己。&lt;/p&gt;

&lt;p&gt;我们有下面这样投机的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;@implementation MyView //继承自UIView
+ (void)load{ //load方法是所有继承NSObject类都拥有的类方法，可以直接理解为这个方法加载的灰常早灰常的早！！
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        Class class = [self class];
        //把原来的方法换掉
        SEL originalSelector = @selector(willMoveToSuperview:);//View被加到父View的时候的回调
        SEL swizzledSelector = @selector(ddwillMoveToSuperview:);
        
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        
        BOOL didAddMethod =class_addMethod(class,
                                           originalSelector,
                                           method_getImplementation(swizzledMethod),
                                           method_getTypeEncoding(swizzledMethod));
        
        if (didAddMethod) {
            class_replaceMethod(class,
                                swizzledSelector,
                                method_getImplementation(originalMethod),
                                method_getTypeEncoding(originalMethod));
        } else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
}

- (void)ddwillMoveToSuperview:(UIView *)newSuperview{
    [self ddwillMoveToSuperview:newSuperview];//这个地方 可自行资料为何用self
    [self setExclusiveTouch:YES];
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这就就是OC的Runtime的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Method Swizzling&lt;/code&gt;，很轻易地实现了AOP打补丁，这样我们的UIView都只能单击啦，哈哈，击溃产品+1。&lt;/p&gt;

&lt;p&gt;更多的资料任意门:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tech.glowing.com/cn/method-swizzling-aop/&quot; target=&quot;_blank&quot;&gt;Method Swizzling 和 AOP 实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然很多优秀的开源项目都是润物细无声的老司机，他们的库不需要添加任何代码就能跑起来，其实这个方式就是AOP，就是使用了load方法和Runtime！&lt;/p&gt;

&lt;p&gt;比如给键盘打补丁老司机的 &lt;a href=&quot;https://github.com/hackiftekhar/IQKeyboardManager&quot; target=&quot;_blank&quot;&gt;IQKeyboardManager&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;fxxkingd。。 噢不 是forking dog团队的给返回手势打补丁的&lt;a href=&quot;https://github.com/forkingdog/UITableView-FDTemplateLayoutCell&quot; target=&quot;_blank&quot;&gt;UITableView-FDTemplateLayoutCell&lt;/a&gt; 这个团队还是非常棒的！他们的开源项目质量都很高！值得学习！&lt;/p&gt;

&lt;h3 id=&quot;category&quot;&gt;Category&lt;/h3&gt;

&lt;p&gt;Category可以给任意一个继承自NSObject的类添加方法，重写方法！ 其作用就是为了轻继承的，所以利用Category同样可以给项目打补丁！&lt;/p&gt;

&lt;p&gt;同样的问题&lt;/p&gt;

&lt;p&gt;『只允许所有的控件的单击』&lt;/p&gt;

&lt;p&gt;我们可以给UIView写一个Category&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#import &quot;UIView+SingleTap.h&quot;

@implementation UIView(SingleTap)
//该方法会直接覆盖原View的方法
-(BOOL)isExclusiveTouch{ 
    return YES;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不足之处就是在使用的时候必须引用该Category的头文件&lt;/p&gt;

&lt;p&gt;当然如果你确定要干掉所有控件的双击，也可以在Pch预编译头文件中引入该Category，这样整个项目的每个文件默认都会引入这个Category，一劳永逸了。&lt;/p&gt;

&lt;h3 id=&quot;notification&quot;&gt;Notification&lt;/h3&gt;

&lt;p&gt;利用通知也能给项目修修补补。&lt;/p&gt;

&lt;p&gt;个人认为作为一个iOS开发者首先都要有一定的YY能力！怎么说？因为我们几乎不可能看到应用层框架源码，所以很多实现机制只能靠猜！也因为这种状况，我觉得iOSer都应该养成一个癖好——对苹果暴露的方法和属性列表要近乎狂热地感兴趣，比如学习一个框架的时候头文件中所有东西都不要放过！也应该学会扫描方法列表和成员变量的技能，比如有好事者把iOS Runtime的所有私有接口都扫面了出来 &lt;a href=&quot;https://github.com/nst/iOS-Runtime-Headers&quot; target=&quot;_blank&quot;&gt;iOS-Runtime-Headers&lt;/a&gt; 这个东西真TM太赞了！！哈哈&lt;/p&gt;

&lt;p&gt;现在我们有这样的一个需求&lt;/p&gt;

&lt;p&gt;『让所有的UITextField不允许输入emoji表情』&lt;/p&gt;

&lt;p&gt;如果在每个使用了UITextField的地方使用代理方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后一个一个字符的检测，如果是emoji的话就删除，想想全局有几十上百的UITextField，就菊花一紧，这么多改起来蛋疼，以后维护起来还会更蛋碎，所以这种方法是绝不可行的！！&lt;/p&gt;

&lt;p&gt;当然就想想AOP、和Category的方式了，当然这些方式必然能做到的，但是我们这里要用别的方法！&lt;/p&gt;

&lt;p&gt;二话不说撸出&lt;code class=&quot;highlighter-rouge&quot;&gt;UITextfieldDelegate.h&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到有几个String常量！看到&lt;code class=&quot;highlighter-rouge&quot;&gt;Notification&lt;/code&gt; 关键字就绝逼是注册接受通知用的了！可以猜到UITextField在各种状态回调时会发出好几个通知：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;UIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;
UIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;
UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我们可以利用着几个通知这么做&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate.m&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{
    /**
     *  监听全局的textview和textfield的EndEidt
     */
    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(enhanceGlobalInputs:) name:UITextFieldTextDidEndEditingNotification object:nil];
    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(enhanceGlobalInputs:) name:UITextViewTextDidEndEditingNotification object:nil];
    return YES;
}
   
   
- (void)enhanceGlobalInputs:(NSNotification*)notification{
    //移除emoji表情 stringByRemovingEmoji是我给NSString写的一个扩展，用于移除Emoji
    if ([notification.name isEqualToString:@&quot;UITextFieldTextDidEndEditingNotification&quot;]) {
        ((UITextField *)notification.object).text = [((UITextField*)notification.object).text stringByRemovingEmoji];
    }else if([notification.name isEqualToString:@&quot;UITextViewTextDidEndEditingNotification&quot;]){
        ((UITextView *)notification.object).text = [((UITextView*)notification.object).text stringByRemovingEmoji];
    }
    
    //限制大数 只允许输入10位长度的数字 isPositiveFloat是一个判断字符串中的数字是否是合法数字的方法,简单的正则匹配
    NSString*(^limitBigNum)(NSString* num) = ^(NSString* num){
        if ([Tools isPositiveFloat:num]) {
            if (num.length&amp;gt;10) {
                return [num substringWithRange:NSMakeRange(0, 10)];
            }else{
                return num;
            }
        }else{
            return num;
        }
    };
    if ([notification.name isEqualToString:@&quot;UITextFieldTextDidChangeNotification&quot;]) {
        ((UITextField *)notification.object).text = limitBigNum(((UITextField *)notification.object).text);
    }else if([notification.name isEqualToString:@&quot;UITextViewTextDidChangeNotification&quot;]){
        ((UITextView *)notification.object).text = limitBigNum(((UITextView *)notification.object).text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSString+Emoji.m&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#import &quot;NSString+Emoji.h&quot;
#include &amp;lt;unicode/utf8.h&amp;gt;

@implementation NSString(Emoji)

- (NSString *)stringByRemovingEmoji {
    NSData *d = [self dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:NO];//有损转换
    if(!d){
        return nil;
    }
    const char *buf = (char*)d.bytes;
    NSUInteger len = [d length];
    char *str = (char *)malloc(len);//分配char*len大小的内存
    unsigned int inputIndex = 0, outpuIndex = 0;
    int uc;//当前unicode字符的编码 十进制表示
    while (inputIndex &amp;lt; len) {
        U8_NEXT_UNSAFE(buf, inputIndex, uc);//一个一个字符遍历
        if(0x2100 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x26ff) continue;//是emoji就放弃本轮循环
        if(0x1d000 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x1f77f) continue;//是emoji就放弃本轮循环
        U8_APPEND_UNSAFE(str, outpuIndex, uc);//不是emoji表情，添加到str中
    }
    return [[NSString alloc] initWithBytesNoCopy:str length:outpuIndex encoding:NSUTF8StringEncoding freeWhenDone:YES];
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;宏替换&quot;&gt;宏替换&lt;/h3&gt;

&lt;p&gt;最后这种方法也许很多人都知道怎么用了，iOS的编译机制是这样的：对于拥有相同方法签名的方法，后编译的会覆盖较早编译的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#pragma mark - 重写NSLog,Debug模式下打印日志和当前行数
#if DEBUG
#define NSLog(FORMAT, ...) fprintf(stderr,&quot;\nfunction:%s line:%d content:%s\n&quot;, __FUNCTION__, __LINE__, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);
#else
#define NSLog(FORMAT, ...) nil
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iOS框架的NSLog会比较早编译，但是最后会被我们应用中的覆盖掉。&lt;/p&gt;

&lt;p&gt;这样就等于给全局的NSLog给打上一个补丁了或者说给NSLog增强了！这个就不赘述了。&lt;/p&gt;

&lt;h2 id=&quot;线上的修补&quot;&gt;线上的修补&lt;/h2&gt;

&lt;p&gt;因为苹果一个多礼拜审核周期的尿性，给一个线上的项目打补丁还是很有意义的。但是线上的打补丁方式条件就要苛刻许多了！一般是在项目中先植入一个引擎类的东西，然后移动端去服务端获取修补的指令(Lua、JavaScript等脚本，至于用什么语言和这个修补引擎的设计有关)，然后这个引擎会将指令通过一定的映射规则生成本地的的可执行指令，比如OC中可以使用Runtime新增类或者修改类，然后达到打补丁的效果，这也称为&lt;code class=&quot;highlighter-rouge&quot;&gt;热更新&lt;/code&gt;技术！下面的都是成熟的热更新引擎，可以学习一下&lt;/p&gt;

&lt;h3 id=&quot;wax&quot;&gt;wax&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.devzeng.com/blog/ios-patch-by-wax.html&quot; target=&quot;_blank&quot;&gt;使用Wax给你的应用程序打补丁&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;jspatch&quot;&gt;JSPatch&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bang590/JSPatch&quot; target=&quot;_blank&quot;&gt;JSPatch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过如果你的项目支持了热更新，那么产品就更加肆无忌惮了，因为你可以给线上的项目打补丁了，所以你懂得~~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;『这样要改一下』。。被吓得都质壁分离了！&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这篇文主要是分享了本人在正式项目中遇到时间紧迫但是急需变更需求的时候的一些解决方法与思路，都是拙见，都是野路子，但是我就是喜欢这样，哈哈 （自带BGM~我就是爱音乐~别叫我停下来~）&lt;/p&gt;

&lt;p&gt;但是，预见性的架构设计思想可以让你避免掉很多的野路子，一份代码的优雅以及可靠都是在一些规范的设计原则上建立起来的，所以哦，像一些基本的设计原则比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Don't repeat yourself&lt;/code&gt; 原则；封装成类，或者在基类中的封装；众多设计模式有良好的扩展和灵活特性的指导；又或者利用其他编程范式如函数式、响应式来写出更加健壮灵活的代码，可以让你的项目更加健壮、灵活、、高效、优雅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2016-5-25-pic12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;散了！回家抄党章避避邪去了，又要改需求。。。。&lt;/p&gt;
</description>
        <pubDate>Wed, 25 May 2016 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/05/25/iOS%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-%E6%89%93%E8%A1%A5%E4%B8%81-%E6%96%B9%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/05/25/iOS%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-%E6%89%93%E8%A1%A5%E4%B8%81-%E6%96%B9%E6%B3%95/</guid>
        
        <category>基础整理</category>
        
        <category>天杀的需求变更</category>
        
        
      </item>
    
      <item>
        <title>Swift中的Weak Strong Dance</title>
        <description>&lt;h1 id=&quot;swift中的weakstrong-dance&quot;&gt;Swift中的Weak/Strong Dance&lt;/h1&gt;

&lt;p&gt;马上又要过年了，诶，再也不能像当初那样无耻地逗利是了(我们广东的方言讨红包的意思)&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-12-23-pic1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-12-23-pic2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看来今年没利了&lt;/p&gt;

&lt;p&gt;谁让哥已经工作了呢。&lt;/p&gt;

&lt;p&gt;公司今年的开发任务算是完结了，苹果又极不负(hǎo)责(yàng)任(de)地放圣诞不审核了，所以这半个月就该清闲下来了。&lt;/p&gt;

&lt;p&gt;博主掐指一算，Swift已经养到2.1了，并且也开源了，这样看来Swift也够肥了，语法也绝逼不会再有大改动了，是该再次抓起来了。&lt;/p&gt;

&lt;p&gt;为什么说再呢，其实在当初Swift Beta版本的时候，我们项目经理尝试了一下palyground后，一拍手，棒棒哒，”我们用Swift开发接下来的项目吧”，然后就是Swift1.0 … 2.0，每一次升级，每一次语法更迭，每一次XCode打开的那一刻都是满江红，那触目惊心的场面无数次让博主受尽折磨。最后庆幸的是，这个项目死了，哦耶！&lt;/p&gt;

&lt;p&gt;好吧，重新捡起Swift吧，今天的这篇文章是一篇激情翻译大作。&lt;/p&gt;

&lt;p&gt;好吧回到博文的主题中来，这次我们说说“Weak/Strong Dance”&lt;/p&gt;

&lt;p&gt;在block中解决循环引用要追寻的&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2011-322/&quot; target=&quot;_blank&quot;&gt;2011 WWDC Session #322&lt;/a&gt; 当时惊艳的代码是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;- (void)dealloc
{
  [[NSNotificationCenter defaultCenter] removeObserver:_observer];
}

- (void)loadView
{
  [super loadView];

  __weak TestViewController *wself = self;
  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot;
                                                                object:nil
                                                                 queue:nil
                                                            usingBlock:^(NSNotification *note) {
      TestViewController *sself = wself;
      [sself dismissModalViewControllerAnimated:YES];
  }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者可以看看&lt;a href=&quot;https://github.com/AFNetworking&quot; target=&quot;_blank&quot;&gt;AFNetWorking&lt;/a&gt; 是这样用block的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;__weak __typeof(self)weakSelf = self;
AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
__strong __typeof(weakSelf)strongSelf = weakSelf;
strongSelf.networkReachabilityStatus = status;
if (strongSelf.networkReachabilityStatusBlock) {
strongSelf.networkReachabilityStatusBlock(status);
}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们都很熟悉Objective-C中的“weak/strong dance”，但是寂寞无聊的我突然就很想知道Swift语言中该怎么做呢？是否存在传说中的最佳实践呢？&lt;/p&gt;

&lt;p&gt;好啦，翻译开始！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://kelan.io/2015/the-weak-strong-dance-in-swift/&quot; target=&quot;_blank&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先，我们祭出一个在闭包中没有使用weak的引用导致的循环引用的例子&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)?&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;deinit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Destroying &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Doing something for &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;one&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;two&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;two&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个巨基础又明显的循环引用的例子，self -&amp;gt; block -&amp;gt;self&lt;/p&gt;

&lt;p&gt;所以，&lt;code class=&quot;highlighter-rouge&quot;&gt;deinit&lt;/code&gt; 方法是绝逼不会被执行的，即使你把 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 重新指向&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;或者其他的实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;也不会被销毁，这就是顽固又调皮的循环引用了，尤其是当你把&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;指向&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;之后，这个对象你就再也引用不了了，它就静静的躺在堆内存里面，遗世而独立，然后你就堆内存泄露了，然后你就淡淡的忧伤从下体传来 ~ ~没有然后了&lt;/p&gt;

&lt;p&gt;其实Swift中闭包的参数列表(&lt;a href=&quot;http://www.russbishop.net/swift-capture-lists&quot; target=&quot;_blank&quot;&gt;Capture List&lt;/a&gt;) 已经能够很好的让你获取一个&lt;code class=&quot;highlighter-rouge&quot;&gt;weak self&lt;/code&gt;来避免循环引用了，但这还达不到我们的要求，只有&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;是构不成“weak/strong dance”滴。&lt;/p&gt;

&lt;h2 id=&quot;使用闭包参数列表&quot;&gt;使用闭包参数列表&lt;/h2&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)?&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 这里做出一些改变&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;deinit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Destroying &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Doing something for &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;one&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;two&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Destroying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;two&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就没有循环引用啦~&lt;/p&gt;

&lt;h2 id=&quot;在闭包中使用self&quot;&gt;在闭包中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[weak self]&lt;/code&gt;有一个细节，就是&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;在闭包中会变成&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; 从上面的代码中&lt;code class=&quot;highlighter-rouge&quot;&gt;self?.doSomething()&lt;/code&gt; 就可以看出来了。&lt;/p&gt;

&lt;p&gt;但是如果你在这个闭包中狂轰乱炸的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;self？&lt;/code&gt; （多次使用&lt;code class=&quot;highlighter-rouge&quot;&gt;self？&lt;/code&gt;），问题就来了，因为这个&lt;code class=&quot;highlighter-rouge&quot;&gt;self？&lt;/code&gt;是一个弱引用的，那么你没法确定在这个闭包中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;self？&lt;/code&gt;操作都能执行完毕，毕竟若引用的&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;可能随时都挂掉，然后怒举一个栗子：&lt;/p&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-12-23-pic4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;deinit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Destroying C&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;before sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;usleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;after sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Optional, so we can set it to nil&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;doClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;usleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// This will dealloc c&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;dispatch_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;before&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Destroying&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;小提示：当然一般来说在&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async()&lt;/code&gt;中你不必担心会有循环引用，因为self并不会持有&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async()&lt;/code&gt;的block，所以上述的代码中并不会真的导致循环引用，如果你的闭包并不是很注重结果的，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;闭包就不会再执行，这个还是挺有用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上述的代码中不会打印&lt;code class=&quot;highlighter-rouge&quot;&gt;after sleep&lt;/code&gt;，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;self？&lt;/code&gt;在打印这句话之前已经挂掉了。&lt;/p&gt;

&lt;p&gt;通常这种无根之源的bug可以把你整的半死。所以通常遇到这种闭包中多次试用&lt;code class=&quot;highlighter-rouge&quot;&gt;self？&lt;/code&gt;的操作的时候，一般会把&lt;code class=&quot;highlighter-rouge&quot;&gt;self？&lt;/code&gt;变为又粗又壮的&lt;code class=&quot;highlighter-rouge&quot;&gt;strong self&lt;/code&gt;，（博主也是又粗又壮的，捂脸~~）这就是传说中的“weak/strong dance”，这个舞蹈，额，什么鬼，为什么把这个技术叫做dance啊，我觉得叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;美队解禁奥义技&lt;/code&gt;还不错，妇联里面的美国队长也是由&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;变成&lt;code class=&quot;highlighter-rouge&quot;&gt;strong&lt;/code&gt;的嘛~，好吧，扯太远，菊花都扯疼了，我们这是在技术翻译呢！要严肃！要尊重原作者！我们还是叫dance吧，有了这个dance之后呢，我们就能确保一旦闭包被执行，&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;就不会为&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但是，就像文章开头说的，对于在&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;的“weak/strong dance”中变回strong的这部分的最佳实践是什么我也不是很确定的。。。&lt;/p&gt;

&lt;h2 id=&quot;获取强引用的一些想法&quot;&gt;获取强引用的一些想法&lt;/h2&gt;

&lt;h3 id=&quot;使用可选绑定if-let&quot;&gt;使用可选绑定&lt;code class=&quot;highlighter-rouge&quot;&gt;if let&lt;/code&gt;&lt;/h3&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 这里就是精髓了&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;before sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;usleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;after sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// or in Swift 2, using `guard let`:&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 这里就是精髓了&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;before sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;usleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;after sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;before&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Destroying&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;很明显的看出整个操作的流程&lt;/li&gt;
  &lt;li&gt;在闭包中拿到了非可选的本地变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;很不幸的是我们不能&lt;code class=&quot;highlighter-rouge&quot;&gt;if let self = self&lt;/code&gt;，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;是常量，不可变，这样的话我们就只能&lt;code class=&quot;highlighter-rouge&quot;&gt;if let strongSelf = self&lt;/code&gt; 在闭包的作用域中都要使用丑陋的&lt;code class=&quot;highlighter-rouge&quot;&gt;strongSelf&lt;/code&gt;了。&lt;/li&gt;
  &lt;li&gt;在swift的闭包中，如果你没有试用&lt;code class=&quot;highlighter-rouge&quot;&gt;strongSelf&lt;/code&gt;而是使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;，这样编译器会警告！因为这个时候&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;是可选的嘛，相比较OC中，就不会警告了。(这句话哥读了21遍，为什么觉得这个不是缺点呢)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用withextendedlifetime&quot;&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;withExtendedLifetime&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在Swift的标准库中有一个函数：&lt;code class=&quot;highlighter-rouge&quot;&gt;withExtendedLifetime()&lt;/code&gt;，感觉就像Apple这个金鱼佬故意诱导我们使用这个函数来实现“weak/strong dance”。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;/// Evaluate `f()` and return its result, ensuring that `x` is not&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;/// destroyed before f returns.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withExtendedLifetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@noescape&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那就试试&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;withExtendedLifetime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;before sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;usleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;after sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;闭包中不再需要使用丑陋的&lt;code class=&quot;highlighter-rouge&quot;&gt;strongSelf&lt;/code&gt;了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;还是他妈可选的，调用方法什么的还是要！？，还是要解包，博主突然想起自己的一个技能：单手解，呵呵&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自定义一个withextendedlifetime&quot;&gt;自定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;withExtendedLifetime()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;这个方法是 &lt;a href=&quot;https://twitter.com/jtbandes&quot; target=&quot;_blank&quot;&gt;@jtbandes&lt;/a&gt; 这哥们想的，大概会是这样：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withExtendedLifetime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Wrapped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Then:&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withExtendedLifetime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;before sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;usleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;after sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Follows naming conventions set by the standard library.(原文) 感觉没优点~&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strongSelf&lt;/code&gt;变成了使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$0&lt;/code&gt; ，博主认为哦，还是很丑陋，并且可读性更差了&lt;/li&gt;
  &lt;li&gt;In this case, I had to add some extra type info to the &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async()&lt;/code&gt; closure. I’m not totally sure why. 不知道他说什么鬼~&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;翻译至此结束了&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;关于Swift中 “Weak/Strong Dance”，中的Weak部分，大家可以参阅喵大的这篇文章 &lt;a href=&quot;https://www.baidu.com/link?url=4d2OoIpoCqnc98N8TJ4PiMR2qoqCe4qm-9LnTIUU4yzHwwVR6KaO1EOOSYNuAowX&amp;amp;wd=&amp;amp;eqid=fb7afdf00006201300000005567b8a3c&quot; target=&quot;_blank&quot;&gt;内存管理,&lt;em&gt;weak&lt;/em&gt; 和 &lt;em&gt;unowned&lt;/em&gt;&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;用回了一个多礼拜的Swift真是感受颇多，虽然Xcode在写Swift还是像纯文本编辑器一样，但是我还是想说一句：Swift真™安全！想crash都难咯。&lt;/p&gt;

&lt;p&gt;收笔，走人。&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Dec 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/12/23/Swift%E4%B8%AD%E7%9A%84Weak-Strong-Dance/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/12/23/Swift%E4%B8%AD%E7%9A%84Weak-Strong-Dance/</guid>
        
        <category>Swift</category>
        
        <category>循环引用</category>
        
        <category>Weak Strong Dance</category>
        
        <category>翻译</category>
        
        
      </item>
    
      <item>
        <title>iOS应用发布中的一些细节</title>
        <description>&lt;h1 id=&quot;ios应用发布中的一些细节&quot;&gt;iOS应用发布中的一些细节&lt;/h1&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;这几天最大的新闻我想就是&lt;code class=&quot;highlighter-rouge&quot;&gt;巴黎恐怖袭击&lt;/code&gt;了，诶，博主每年跨年都那么虔诚地许下“希望世界和平”的愿望，想不到每年都无法实现，维护世界和平这么难，博主真是有心无力啊，其实芸芸众生的我们能做的大概就是不要闯红灯、不抢小妹妹的甜筒、拉完屎记得冲水、打饭不逃票、不在澡堂小便、不挖人家墙角……其实就是维护世界和平了。&lt;/p&gt;

&lt;p&gt;然而黑客组织&lt;strong&gt;Anonymous&lt;/strong&gt;向ISIS宣战了！&lt;/p&gt;

&lt;p&gt;图0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-17-pic0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;威武！&lt;/p&gt;

&lt;p&gt;好吧回归这次文章主题，就列举一些iOS应用发布中个人觉得还蛮容易忽略的一些细节。&lt;/p&gt;

&lt;h2 id=&quot;bundle-identifier&quot;&gt;Bundle identifier&lt;/h2&gt;

&lt;p&gt;Xcode中 &lt;code class=&quot;highlighter-rouge&quot;&gt;Target -&amp;gt; General&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle identifier&lt;/code&gt; ;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;info.plist&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bundle identifier&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/account/ios/certificate/certificateList.action&quot; target=&quot;_blank&quot;&gt;证书中心&lt;/a&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;Identifiers&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;App IDs&lt;/code&gt;新建App时的&lt;code class=&quot;highlighter-rouge&quot;&gt;Explicit App ID&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;iTunes Connect&lt;/code&gt;中App信息的&lt;code class=&quot;highlighter-rouge&quot;&gt;套装ID&lt;/code&gt; 必须保持一致！！&lt;/p&gt;

&lt;p&gt;在info.plist或者Xcode里的各种设置中，有很多&lt;code class=&quot;highlighter-rouge&quot;&gt;$(XXX)&lt;/code&gt;这样的像脚本一样的东西，所以补充一点Xcode中的&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html&quot; target=&quot;_blank&quot;&gt;环境变量&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;certificates证书&quot;&gt;Certificates证书&lt;/h2&gt;

&lt;p&gt;苹果的证书体系一直都是iOS初学者无尽的梦魇，什么开发证书、发布证书、推送证书，什么ad hoc、内测分发、真机调试……我想每一个iOS初学刚开始接触Apple的证书体系的时候内心是绝壁崩溃并且被心中的草泥马践踏的体无完肤的……。&lt;/p&gt;

&lt;p&gt;其实苹果的证书其实没那么玄乎，很多朋友弄不懂或者过了一段时间又不知道怎么弄了，本质的原因是因为对&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86&quot; target=&quot;_blank&quot;&gt;非对称加密(公开密钥加密)&lt;/a&gt;的不理解&lt;del&gt;导致的&lt;/del&gt;，所以为了完全的驾驭苹果的证书，这些基础的知识就是坑你的坎，必须跨过去的。&lt;/p&gt;

&lt;p&gt;网上有各种解释证书中心里面每一种证书作用是什么、怎么创建、怎么使用的，但是这也只能授人以鱼，所以博主不会介绍每一种证书是干嘛的，因为你看前年多了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Pass Type ID Certificate&lt;/code&gt; ，去年又有了&lt;code class=&quot;highlighter-rouge&quot;&gt;WatchKit Services Certificate&lt;/code&gt; ，今年又来一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple Pay Certificate&lt;/code&gt;……根本就解释这些证书不完嘛~，所以理解这些证书的统一规律才是王道！所谓&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;万变不离其宗&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多资料都把证书分成两种，分为开发证书(development)、以及发布证书(distribution)。但是博主认为这样分类不是很不科学的，博主的理解的分类是这样的&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-17-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;是与开发者或者企业对应的，只要是被&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;签名的App都可以理解为是这个证书对应的开发者开发的。所以一个&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;可以签名多个App。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;呢是与具体的App对应的，一个App的推送证书是无法给另一个App使用的，所以一个&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;只能为一个App签名，更确切的说是这个App需要使用某一项Apple的服务而去产生这个&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以其实苹果每年都添加的证书属于&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;，这些其他证书并不是非必须的，而是使用了苹果的某一项服务时才需要提供的凭证。而&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;是必须的，它签名的APP是属于这个证书的所有者的。&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-17-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中我的这个账号默认会有两个不同用途的&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;，有两个App，分别为App1、APP2，以及它们对应的两种用途的推送证书(属于&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;假如我现在需要真机调试App1的推送，那么我只要下载&lt;code class=&quot;highlighter-rouge&quot;&gt;开发根证书&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;App1的开发推送证书&lt;/code&gt;然后双击打开导入钥匙串，然后创建相应profile即可真机调试了；&lt;/p&gt;

&lt;p&gt;假如现在我要发布APP2，那么我只要下载&lt;code class=&quot;highlighter-rouge&quot;&gt;发布根证书&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;APP2的发布推送证书&lt;/code&gt;，然后创建相应地profile即可打包上传App Strore了。(这里因为发布的特殊性，所以发布的电脑必须是创建这个&lt;code class=&quot;highlighter-rouge&quot;&gt;发布根证书&lt;/code&gt;的电脑)。&lt;/p&gt;

&lt;p&gt;profile(描述文件)下文还有篇幅介绍。&lt;/p&gt;

&lt;p&gt;我TM都绕晕了，确实有点麻烦有点复杂，果然iOS开发门槛就是高啊，但是哥就喜欢。&lt;/p&gt;

&lt;h2 id=&quot;app-ids&quot;&gt;App IDs&lt;/h2&gt;

&lt;p&gt;在相应地App的edit中可以添加多套APNs推送证书(其他的证书也类似的)&lt;/p&gt;

&lt;p&gt;图3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-17-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这里声明一下，&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;其他证书生成的时候，使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;certSigningRequest&lt;/code&gt;文件可以和产生&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;certSigningRequest&lt;/code&gt;的不一致，也就是说产生&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;时不一定需要产生&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;的电脑，所以这里也坑了无数的人调试推送，这个在下文&lt;a href=&quot;#推送的一切&quot;&gt;推送的那些事&lt;/a&gt;详细填坑。&lt;/p&gt;

&lt;h2 id=&quot;provisioning-profiles描述文件&quot;&gt;Provisioning Profiles描述文件&lt;/h2&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-17-pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我想这个界面一弹出来的时候，蛋蛋忧伤迎面扑来。然后怒点 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;，然后你们团队负责管理证书的基友突然发现证书中心多了好多好乱的证书以及描述文件，然后他爆了一句：what the huck！删掉了带有&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode *&lt;/code&gt;的证书以及描述文件，然后自己又暴力的点了一发&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;，然后你突然调试不了了，再暴击&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;键，最后整个团队都只有通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;来真机调试了……。&lt;/p&gt;

&lt;p&gt;所以慎点&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;，如果点击这个选项，聪明的(&lt;del&gt;蠢哭的&lt;/del&gt;)Xcode就会自己管理描述文件，然后各种莫名其妙的带有&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode *&lt;/code&gt;的证书以及描述文件……&lt;/p&gt;

&lt;p&gt;其实只要坚信一点，证书、设备ID、AppID、描述文件都弄对了就绝逼不会出问题的！&lt;/p&gt;

&lt;p&gt;描述文件工作原理&lt;/p&gt;

&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-17-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其实描述文件工作的原理就是在APP打包或者真机调试的时候，让Xcode去检查描述文件里面的BundleID与这个APP的BundleID是否对应。&lt;/li&gt;
  &lt;li&gt;对应的话就会去&lt;code class=&quot;highlighter-rouge&quot;&gt;keyChain&lt;/code&gt;查找有没有相应地证书(所以证书要下载好，并且导入&lt;code class=&quot;highlighter-rouge&quot;&gt;keyChain&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;如果有证书存在的话就会检查证书的类型，如果是开发证书，则会检查调试的设备是否加入了描述文件里面的信任设备ID列表，如果设备没有在描述文件的列表中，则无法调试；如果证书类型是发布证书则不会检查设备ID列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;额外地，如果公司新增了测试机，并且在证书中心的&lt;code class=&quot;highlighter-rouge&quot;&gt;Devices&lt;/code&gt;中添加了新测试机的ID，这样描述文件也要相应地更新，然后重新下载，下载完之后可以先删除旧的描述文件(博主直接覆盖的方式貌似描述文件没有更新啊)，你们可以自己做实验咯，描述文件的路劲&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/XXX/Library/MobileDevice/Provisioning\ Profiles&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XXX&lt;/code&gt;你的用户名。&lt;/p&gt;

&lt;p&gt;不要覆盖！记得先删除，可以免除很多问题。&lt;/p&gt;

&lt;h2 id=&quot;推送的那些事&quot;&gt;推送的那些事&lt;/h2&gt;

&lt;p&gt;如果说亿万级用户的微信推送服务并不是企鹅自己定制的而都是由苹果APNs推送的话，那苹果的推送就真的牛逼了，但是有时候测试推送，经常APNs要死不活的，推了半天才到，有一次在APNs沙箱环境怒推1000多条，然后这条队列持续了半个月才推完~~。所以微信、扣扣肯定是定制的推送，有钱就是讨厌，那么任性。&lt;/p&gt;

&lt;p&gt;但是苹果推送的开发是比较简单地，如果没有高级推送需求基本就不用写代码了，只要配置好证书一切OK。&lt;/p&gt;

&lt;p&gt;现在常用的后台server中，一般将推送证书以及推送证书的私钥导出p12交给后台人员即可。&lt;/p&gt;

&lt;p&gt;PHP有点调皮，还需要转换成pem&lt;/p&gt;

&lt;p&gt;生成PHP需要的Pem证书&lt;/p&gt;

&lt;p&gt;准备：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;苹果服务器证书端设置正确！打包证书、描述文件正确！！&lt;/li&gt;
  &lt;li&gt;下载推送证书(cer格式)，导入keyChain，保证私钥存在，不存在去找创建这个证书的电脑要一份过来。&lt;/li&gt;
  &lt;li&gt;从钥匙库导出的&lt;del&gt;根证书&lt;/del&gt;(推送证书)私钥(p12格式)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第三步根证书的私钥这里是一个坑！因为一个App的推送证书的创建可以和根证书创建的电脑不同，也就是keyChain产生的&lt;code class=&quot;highlighter-rouge&quot;&gt;certSigningRequest&lt;/code&gt;不一样，所以私钥也是不一样的，在这里生成Pem时，注意要使用推送证书的私钥！&lt;/p&gt;

&lt;p&gt;操作过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;把推送证书(.cer)转换为.pem文件，执行命令：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;openssl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x509&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;der&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把推送证书导出的私钥(.p12)文件转化为.pem文件：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;openssl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pkcs12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nocerts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书私钥&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书私钥&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p12&lt;/span&gt;	
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对生成的这两个pem文件再生成一个pem文件，来把证书和私钥整合到一个文件里：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书私钥&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PHPPush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后把这个PHPPush.pem给后台基友们，就可以下班啦。&lt;/p&gt;

&lt;p&gt;当然测试推送也比较麻烦，需要模拟真实的推送环境，一般需要后台提供帮助，但是遇到一些后台同事，他们有强烈地信仰着鄙视链的话，很鄙视iOS，心里早就称呼你“死前段”多年了，还那么多事……&lt;/p&gt;

&lt;p&gt;所以关于调试推送，博主教你自己推自己！不麻烦别人。&lt;/p&gt;

&lt;p&gt;只要拷贝这段代码&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// devicetoken
&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'你的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceToken&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 私钥密码，生成pem的时候输入的
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passphrase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123456&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 定制推送内容，有一点的格式要求，详情Apple文档
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'你收到一个新订单'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aps&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sound&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;badge&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_type&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'新订单提醒'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'你收到一个新消息'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream_context_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stream_context_set_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssl&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;local_cert&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//记得把生成的push.pem放在和这个php文件同一个目录
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream_context_set_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssl&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passphrase&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passphrase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream_socket_client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//这里需要特别注意，一个是开发推送的沙箱环境，一个是发布推送的正式环境，deviceToken是不通用的
&lt;/span&gt;	&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//gateway.sandbox.push.apple.com:2195', $err,
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//'ssl://gateway.push.apple.com:2195', $err,
&lt;/span&gt;	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STREAM_CLIENT_CONNECT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STREAM_CLIENT_PERSISTENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Failed to connect: $err $errstr&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;APNS&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delivered&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;successfully&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delivered&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面的代码复制，保存成push.php&lt;/p&gt;

&lt;p&gt;然后根据上面“生成PHP需要的Pem证书”的步骤生成push.pem&lt;/p&gt;

&lt;p&gt;两个文件放在同一目录&lt;/p&gt;

&lt;p&gt;执行下面的命令&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;DavidDay&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;php&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果为&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;APNS&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;successfully&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delivered&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是就推送成功了呢？呵呵哒&lt;/p&gt;

&lt;h2 id=&quot;打包分发及内测&quot;&gt;打包、分发及内测&lt;/h2&gt;

&lt;p&gt;关于打包是有很多姿势的，每个人都有各自的喜好，大部分规矩的做法都是使用Xcode的一条龙服务的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选择相应地描述文件、证书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择ARM架构机型(模拟器是Intel架构的，真机是ARM架构的，不能通用)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;product -&amp;gt; archive&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后就可以选择导出ipa在第三方平台分发测试或者上传App Stroe审核了&lt;/p&gt;

    &lt;p&gt;​
这样的做法比较保险，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;archive&lt;/code&gt; 只会编译出真机的二进制码，所以不用担心导出的ipa真机装不起。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一种姿势是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;xcodebuild&lt;/code&gt; 工具，纯Shell编译，比较不好处理错误，但是逼格满满啊，想详细了解这种姿势的可以看看&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt; ，或者参考这位同学的&lt;a href=&quot;http://www.cnblogs.com/brycezhang/p/4097487.html&quot; target=&quot;_blank&quot;&gt;分享&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然嘛，博主作为拖拖派的忠实拥趸，博主打包ipa的时候是这样的：&lt;/p&gt;

&lt;p&gt;图6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-17-pic6.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随时build随时转ipa。&lt;/p&gt;

&lt;p&gt;分发内测一般都会使用第三方的平台，&lt;a href=&quot;fir.im&quot; target=&quot;_blank&quot;&gt;fir&lt;/a&gt;、&lt;a href=&quot;http://www.pgyer.com/&quot; target=&quot;_blank&quot;&gt;蒲公英&lt;/a&gt; 都很好呀~&lt;/p&gt;

&lt;p&gt;关于提交审核这里，一般archive过去了，证书正确都没问题的，当然还是要检查项目是否调用了私有API，之前用&lt;a href=&quot;http://revealapp.com/&quot; target=&quot;_blank&quot;&gt;reveal &lt;/a&gt; ，提交应用的时候忘了移除，千不该万不该的还是用了Xcode的upload工具，也不报错，在iTunesConnect中构建版本也出现了，只是状态“正在处理”，一般这个状态持续10分钟~2个小时就会通过了，然后博主自信关机下班，想不到第二天构建版本还是“正在处理”，然后猜想是不是iTunes出问题了又怒传了N个包，依然是“正在处理”，后来准备发邮件，打开邮箱，尼玛！&lt;/p&gt;

&lt;p&gt;图7&lt;/p&gt;

&lt;p&gt;原来调用了私有接口，忘记移除reveal了~，回顾起来这里有三个大坑，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Xcode的上传工具很辣鸡！！很多错误都无法扫描出来，所以切记 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Application Loader&lt;/code&gt; ，速度快，错误报告也精准。&lt;/li&gt;
  &lt;li&gt;iTunesConnect的错误状态几乎没有，一般只有两个状态 “正在处理”、“成功”，所以如果超过两个小时仍然是“正在处理”，那么极有可能包出问题了！&lt;/li&gt;
  &lt;li&gt;记住关注邮件！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;打包项目证书选择必须正确 (Xcode7以下 选择项目编译target为Iphone Device 不要连接手机 否则会 ，Xcode7中不需要拔出真机，因为多了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;build only device&lt;/code&gt; 的选项）&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;err&quot;&gt;编译&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;选错了&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;报错&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;ITMS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90530&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Invalid MinimumOSVersion. Apps that only support 64-bit devices must specify a deplyment target of 8.0 or later&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IMTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90208&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Invalid Bundle. The bundle xxx.app does not support the minimum OS version specified in the Info.plist&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IMTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90502&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Invalid Bundle. Apps that only contain the arm64 slice must also have'arm64' in the list of UIRequiredDeviceCapabilities in Info.plist &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;突然想起我哥说的一句话&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有时候有些女人就像饭堂饭菜，虽然难吃，但是去晚了也会没有的！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;珍惜身边的人。&lt;/p&gt;

&lt;p&gt;感觉这个总结什么鬼？有点伤感，嗯，iOS应用的发布，每个从业者都应该能够熟练的对发布进行操作和意外处理的。&lt;/p&gt;

&lt;p&gt;没钱结婚。&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Nov 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/11/17/iOS%E5%BA%94%E7%94%A8%E5%8F%91%E5%B8%83%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/11/17/iOS%E5%BA%94%E7%94%A8%E5%8F%91%E5%B8%83%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</guid>
        
        <category>拾遗集</category>
        
        
      </item>
    
      <item>
        <title>半年的iOS代码生活</title>
        <description>&lt;h1 id=&quot;半年的ios代码生活&quot;&gt;半年的iOS代码生活&lt;/h1&gt;

&lt;p&gt;在高考大军中拼杀过，也在大学校园中荒芜过，曾经低迷消沉，也常满怀壮志…… 但是最多的还是被称为小伙子以及自称为iOS工程师！博主就是这种喜闻乐见的这类人，实习一年后在2015年的毕业季顺利拿到了自己向往的一家创业公司的offer，也许相比很多毕业季的同学职场上顺利许多，但当深夜来临，显示器熄灭后望着荧幕出神的时候，毕业季我错过了很多也许一辈子都不会再相见的同学们的合影。半年里真正领略到了企业项目的开发的艰辛，以及团队协作的魅力，有太多太多的要说，终将其汇成一句话：哥加班半年后终于回来了！&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-11-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;半年时间，反正撸啊撸段位已经是万劫不复了，iOS9一发布加班的觉悟早有了，潜伏的XCodeGhost也被拎出来了，各种被脱裤的同行大佬们也是尿了一地，哥也被吓了一哆嗦，赶忙修改了1024的账号密码…… 2015年就是伴随这些琐事发展着，但是博主作为一个初入职场半年的工作总结当然不会是简单地流水账。&lt;/p&gt;

&lt;p&gt;我知道你们都惦记着什么是1024，1024就是，呵呵，就是一款妈妈都说好玩的游戏啊~。&lt;/p&gt;

&lt;h2 id=&quot;学习&quot;&gt;学习&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;干挨踢的学会学习远比你死背一个功能的代码来的有用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在iOS学习中去尝试体会Cocoa模式，多留意Cocoa中的框架的类，他们的命名都有规范，相似抽象的对象会有相似的方法或者写法，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;Mutable&lt;/code&gt;的类可能都有&lt;code class=&quot;highlighter-rouge&quot;&gt;addXX&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;appendXX&lt;/code&gt;方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;类型的类可能都会有&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerateXX&lt;/code&gt;的遍历方法……，又比如一个类的功能如果注重过程的话，苹果会选择使用&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;的方式，注重结果的话则会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; ，学会总结比较、触类旁通、举一反三！&lt;/p&gt;

&lt;p&gt;如果你能做到对Cocoa模式很熟悉的话，那么最新的3DTouch功能直接看类的头文件就会用了。&lt;/p&gt;

&lt;p&gt;并且，第三方优秀的、热门的库都会遵循这一套编写规范，所以使用起来或者修改起来也才能够游刃有余！除了&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot;&gt;ReactiveCocoa&lt;/a&gt;之流除外。。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;学习时候看一本书远没有敲一个项目来的有效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看书的时候总是会犯一个毛病，就是一看就懂，一写就懵。所以学习技术，我更推荐的是实践检真知！敲出来的代码才是学习到的，因为你在电脑前，你遇到不懂的你可以立刻Google，看到感兴趣的新类可以直接&lt;code class=&quot;highlighter-rouge&quot;&gt;option&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;左键&lt;/code&gt;查看文档或者&lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;左键&lt;/code&gt;直接摆出头文件一览无遗！&lt;/p&gt;

&lt;p&gt;当然&lt;a href=&quot;https://developer.apple.com/wwdc/&quot; target=&quot;_blank&quot;&gt;WWDC&lt;/a&gt;别忘了看看，这是iOS最前沿的技术教学，即使听不懂也没关系，把音频外放，同事问你：哇，你听得懂呀。你微微一笑答道：听不懂。留下认真聆听却似享受的一道背影给同事，那可是满满的逼格。。呵呵，其实不然，视频中有大量PPT，有关键字，拿出来Google一番，再敲打一番，肯定你心中会觉得不虚此举哈，这样也锻炼了英文水平，这样的一波绝逼不亏呀。&lt;/p&gt;

&lt;p&gt;说到英文，这个是技术进阶的基础，不要畏惧，刚开始看一篇英文文档可能花费你一天的时间，但是这才是第一手资料！国内译者的水平毕竟参差不齐，谬误在所难免，而且二手的资料，对于充满处女情结的你能接受么？能忍么？所以百度还是用来搜搜绯闻、床照之流就好，技术索引真不是它的强项，搜出来的东西都是&lt;code class=&quot;highlighter-rouge&quot;&gt;deprecated&lt;/code&gt;的，实在浪费感情。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nshipster.com/&quot; target=&quot;_blank&quot;&gt;NSHipster&lt;/a&gt;、&lt;a href=&quot;https://www.objc.io/&quot; target=&quot;_blank&quot;&gt;Objc.io&lt;/a&gt; ……都是不错的去处，大量的紧巴巴的干货，他们都有中文版，但是最新的资料的中文版还是会相对滞后。&lt;/p&gt;

&lt;p&gt;再一个就是大婶们的博客，一天不读都浑身难受！&lt;/p&gt;

&lt;p&gt;之前拜阅&lt;a href=&quot;http://blog.devtang.com/&quot; target=&quot;_blank&quot;&gt;唐巧Boy&lt;/a&gt;的新书的时候，有一个博客列表非常不错，强势插入我的&lt;a href=&quot;http://feedly.com/&quot; target=&quot;_blank&quot;&gt;Feedly&lt;/a&gt;列表，我自己也有一些关注的大婶也加入了列表当中，这里给出分享OPML&lt;a href=&quot;https://daiweilai.github.io/attach/feedly.opml&quot;&gt;拿去玩&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;沙龙、研讨什么的可以适当参加，看看荧幕外的世界，不要老说没有搞iOS的姑娘。&lt;/p&gt;

&lt;h2 id=&quot;团队&quot;&gt;团队&lt;/h2&gt;

&lt;p&gt;讲一个故事：从前有个产品经理，他修改了3次需求，第二天他死了。&lt;/p&gt;

&lt;p&gt;博主只想说的是，若不是博主心慈，我想我公司的产品经理已经死完后投胎又死一百次了。&lt;/p&gt;

&lt;p&gt;我们都知道项目完成的水平直接由团队中是否有高效的协作而决定，也许有很多程序员长期的孤高冷艳惯了，他们说自己不需要团队！自己一个人就可以搞定一切，自己是UI、UE、产品、编码、测试甚至后端一条龙拿下，但是你将没有女朋友！！！&lt;/p&gt;

&lt;p&gt;团队协作远比个人的英雄主义更有魅力，个人认为！&lt;/p&gt;

&lt;p&gt;当下的快速迭代的大环境下，企业级开发下英雄主义是不太可取也不太可行的，所以融入团队，学会交流是工作顺利进展的保证；&lt;/p&gt;

&lt;p&gt;当然团队协作中是否高效是否愉快就需要交流技巧了，每个人都有自恋的情节，即使是自己的工作技能也是如此，所以世界上存在着各种鄙视链&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-11-pic2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举一个简单地例子吧&lt;/p&gt;

&lt;p&gt;公司常见撕逼的三个部门：研发部、产品部、市场部&lt;/p&gt;

&lt;p&gt;研发的看不起产品、市场，觉得他们都不懂技术，只是天马行空，遇到Bug还大惊小怪……&lt;/p&gt;

&lt;p&gt;产品的觉得自己的设计是天才的设定，参考了社会伦理学，色彩心理学，严格的人体工学设计……反驳自己的都是傻逼……&lt;/p&gt;

&lt;p&gt;市场的觉得自己深入客户，自己才是最了解这个产品市场的，所产品应该按自己的市场为导向，颜色不对，字体客户肯定不喜欢，改改改……&lt;/p&gt;

&lt;p&gt;在排除消极因素，投机倒把的极个别人存在，团队中的成员还是希望共同的目标能够完美的实现的，也就是说其实我们的“争吵”也是为了更好的产品，但是“争吵”的度确实很难把握，难免就因为工作却伤了私下的感情，这也是离职中众多原因之一，频繁的离职却会使得你的职业生涯成长增加时间成本，所以更好的工作方式是“学会交流”。&lt;/p&gt;

&lt;p&gt;“学会交流”不单单是工作中用到，这也是我们的一生的学问！&lt;/p&gt;

&lt;p&gt;例如有时候，产品部门不是很负责任的频繁变更需求，这可苦了研发的成员，你便可以玩笑似的给他讲一个故事：从前有个产品经理，他修改了3次需求……，我想这样的诙谐即会是的工作氛围愉悦许多也可能让产品的同事知道自己不负责任行为的影响。&lt;/p&gt;

&lt;p&gt;但是需求变更，这个是研发一直要面对课题，所以你必须学会“预置性开发”，预置性包括使用一些优秀的设计模式的使用降低模块间的耦合，增加系统维护的灵活性，也可以有类似&lt;code class=&quot;highlighter-rouge&quot;&gt;Placeholder&lt;/code&gt;的编码技巧，来随时应对不期而遇的需求变更，具体的做法，这也许需要另开一篇博文来讲述。&lt;/p&gt;

&lt;h2 id=&quot;健康&quot;&gt;健康&lt;/h2&gt;

&lt;p&gt;如果还没有升职加薪，当上总经理，出任CTO，迎娶白富美，走向人生巅峰。却出师未捷身先死，这个都不太好玩，身边的同事以及博主自己都有或多或少的职业病产生了，博主躬亲力行地验证了一个道理：樯橹灰飞烟灭！别说撸代码还真的很带感，根本停不下来，所以最后颈椎，肩膀就是各种不适。说多都是泪，不过后来博主秉承了国人”先污染后治理”的方针，总算把身子调过来了，秘笈如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;练此功，不强制自宫&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;好吧，这才是第一条，”不可久坐”x循环3次！！很重要，久坐流入脑子的血液会增加，从而造成下肢浮肿。由于久坐只限于局部肌肉活动，缺乏全身较大肌群动作，时间一长，久不动作的肌肉会逐步萎缩，机能衰退，还会使心、肺的后备能力降低，不能适应肌肉活动对血液循环和氧气供应的要求，一动就会心跳气急。肌肉长期不活动，热量消耗少，会加重脂肪和糖的代谢障碍，导致身体过分肥胖、动脉硬化及糖尿病。而且久坐一般皮肤质量较差，长时间静坐，受压血液流通不畅，易引起臂部瘙痒和隐痛，伏案工作者更甚，长期下去易导致颈椎炎，肩周炎，腰椎突出，脊柱变弯……我编不下去了，就问你怕不怕！！！所以多起身活动往非技术部走走，不然就会生病的哟(认不出雌性生物了)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;坐姿&lt;/p&gt;

    &lt;p&gt;图2&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-11-11-pic3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;尝试全键盘操作，多记记几个快捷键世界就安静了，反正博主的magic mouse干电池已扣，什么你的是最新款的鼠标没干电池？那为了你的健康着想拿给博主用吧，可减少手腕以及肩膀劳损的风险。这里分享一个Mac屏幕效率工具&lt;a href=&quot;http://www.irradiatedsoftware.com/&quot; target=&quot;_blank&quot;&gt;SizeUp&lt;/a&gt; 可减少鼠标的使用！&lt;/li&gt;
  &lt;li&gt;运动运动运动！不要在被人黑了，老是被黑码农，油头垢面，肾虚患者……有意思么？我们是改变世界的工程师！不要再穿拖鞋上班了！！大家薪水都不低，穿得体面点吧。你可以和博主一样帅的。&lt;/li&gt;
  &lt;li&gt;努力陪伴回你身边一直陪伴着你的人，那使你的精神最远是最佳的状态！什么？那就多打打电话给你妈妈吧，那是最美的人。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;追求&quot;&gt;追求&lt;/h2&gt;

&lt;p&gt;不要担心30岁要转行，不要认为30K就是终点，不要一天工作30个小时。保持初心。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;O ever youthful,O ever weeping.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;博主新开了一个博客系统，托管在了Github.io上，喜闻乐见的Jekll加借鉴&lt;del&gt;(抄袭)&lt;/del&gt;的精美主题构建而成，反正样子应该还看得过去，如果有朋友有兴趣想了解iOS程序员为何日撸万行代码？数百奇巧淫技如何施展？无数干货为何频频送出？究竟编译器背后又隐藏着什么？这一切的背后是技术与生活的碰撞还是高效与投机的权衡？我真TM编不下去了，欢迎前往 &lt;a href=&quot;https://daiweilai.github.io&quot; target=&quot;_blank&quot;&gt;[任意门]&lt;/a&gt;围观。&lt;/p&gt;

&lt;p&gt;严肃地，如果你刚开始学习iOS开发或许可以从博主这里得到一些半干货。&lt;/p&gt;

&lt;p&gt;生活愉快！&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Nov 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/11/11/%E5%8D%8A%E5%B9%B4%E7%9A%84iOS%E4%BB%A3%E7%A0%81%E7%94%9F%E6%B4%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/11/11/%E5%8D%8A%E5%B9%B4%E7%9A%84iOS%E4%BB%A3%E7%A0%81%E7%94%9F%E6%B4%BB/</guid>
        
        <category>闲暇集</category>
        
        
      </item>
    
      <item>
        <title>iOS各种调试技巧</title>
        <description>&lt;h1 id=&quot;ios各种调试技巧&quot;&gt;iOS各种调试技巧&lt;/h1&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近博主临近毕业季，为了完美的写一篇毕业论文，真是：“锄禾日当午，汗滴禾下土”&amp;lt;—— 这句诗跟毕业我写毕业论文没任何一毛钱关系，我就是突然想吟湿了。不过博主作为网络工程专业的好青年，曾经的愿望和理想就是在下水道干出一番轰轰烈烈的大事业，没错是就是下水道，我们的征途在下水道！！不过大家别误会，我不是忍者龟的脑残粉！听我继续说！我想的是等我在各大排水系统各大下水道功成名就的时候，我就可以指着一个井盖对我的孙子说：“诺 那个下面的通信光缆是爷爷我接的！！” 我满脸自豪地接受着这孙子的敬仰！但是啊，曾经的愿望都实现不了了，我深深爱着的地下通信光缆啊，曾经多少个夜晚泪水打湿了我的毕业论文，渲染开的笔墨那都是哥逝去的青春啊。&lt;/p&gt;

&lt;p&gt;因为生活就像开了博主一个玩笑，让博主遇到了一种鸡，那是一种特殊品种的鸡，它叫做逼优鸡！！就是这只鸡让博主无缘无故的成了一只APM超200的野生究极程序猿！！吼~ 嗷~，把博主带离了下水道！并且与这只鸡踏上另一端征途！临走的时候，下水道的通信光缆就交给你们了，肥皂基友们(网络工程的基友们)！！我靠，他们竟然在打印店花了50块钱就直接买了一套深度豪华毕业论文套餐！里面包含了论文，工程制图，CAD，报价清单，拓扑结构……最重要的是老板承诺不需任何修改，直接可以通过毕业答辩，不通过来年免费再提供一套论文，最贴心的是竟然支持通过再付款！！，&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;老子写论文写了半个月像狗一样，他们竟然直接就买了！就这么买过去了！！对得起老师的谆谆教诲、自己的辛苦付出和父母的期待么？我就问你们惭愧不惭愧？为什么买的时候不喊上我？泪已淌干~&lt;/p&gt;

&lt;p&gt;扯蛋过多容易肾亏&lt;/p&gt;

&lt;h2 id=&quot;逼优鸡&quot;&gt;逼优鸡&lt;/h2&gt;

&lt;p&gt;终于来到了大家期待的正片，今天我就要和大家讲我和逼优鸡的故事，逼优鸡它优雅低调，它身材玲珑，藏匿在黑暗处，挑动着我的欲望！曾多个日夜博主都……（擦！尼玛，逼优鸡是什么鬼？说好的技术文章?）同学你真的(biè)急，你先坐下，先把鞋子穿好！我说的逼优鸡它的英文名叫做(Bug)，它挺(T)美(M)的(D)……&lt;/p&gt;

&lt;p&gt;歌仔唱的好：&lt;/p&gt;

&lt;p&gt;多少猿曾被它夺走年轻的容颜&lt;/p&gt;

&lt;p&gt;多少猿曾在它面前亮门秃了头&lt;/p&gt;

&lt;p&gt;多少Bug曾经生命中来了又还&lt;/p&gt;

&lt;p&gt;可知一生有你我都陪在你身边&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;无数个夜晚你揪着头发和Bug撕咬的情景博主可以体会，所以这次的这篇文章博主就要给大家整理一个调教iOS逼优鸡的方法豪华套餐！！放心！绝对的深度豪华，因为已经加入肯德基豪华午餐~咳咳~其实是因为逼优鸡(Bug)对于我们毕竟是除了老婆之外第二可怕的存在！我们必须要练就铜头铁臂十八般武艺，祭练奇门巧技各种大杀！方可与之周旋并将之歼灭！好！跟着博主一起装逼一起飞吧！！！！&lt;/p&gt;

&lt;p&gt;第一步：&lt;/p&gt;

&lt;p&gt;我看大家蓬头垢面的就知道大家刚刚也才debug回来 ，我们就先写个hello world压压惊把！&lt;/p&gt;

&lt;p&gt;第二步&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;知己知彼 百战不殆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此处为大量Copy！不喜请喷！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The software doesn’t do something that the product specification says it should do.&lt;/p&gt;

  &lt;p&gt;The software does something that the product specification says it shouldn’t do.&lt;/p&gt;

  &lt;p&gt;The software does something that the product specification doesn’t mention.&lt;/p&gt;

  &lt;p&gt;The software doesn’t do something that the product specification doesn’t mention but should.&lt;/p&gt;

  &lt;p&gt;The software is difficult to understand, hard to use, slow, or in the software tester’s eyes will be viewed by the end user as just plain not right.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;我不是英文教师，请大家自行切换多语言阅读模式。&lt;/p&gt;

&lt;p&gt;也还有有人粗暴的定义 ”Bug就是错误“，除了世界上第一只Bug是飞进去的那只虫子外，其他Bug毋庸置疑那都是程序员们自己生下来的！程序员们自己犯的错误！如果说一个软件作品(请尊重你自己的作品，不要喊他们”产品”或者”项目”)是程序员们自己的孩子，那么Bug就是这个孩子的生的病，有病得治，药不能停！生病有各种治疗方法，物疗，理疗，化疗，心理疗……那么“治疗”Bug也是有多中方法的！下面博主会一一列举！惩治这些个Bug之前，博主要先阿拉巴拉一番，遇到Bug也是一件比较哔了狗了的事情，你要知道任何人都会生病，没有例外！所有任何代码都有Bug这是定理，我们首先要从心态上端正Bug这件事情，我们可以理解为缺憾也是一种美，就像阿雨说的“没有皱纹的祖母是可怕的，没有白发的老者是让人遗憾的。没有废墟的人生太累了，没有废墟的大地太挤了，掩盖废墟的举动太伪诈了。”Debug是为了证明程序有错，而不是证明程序无错误；所以我们要做到临Bug而不惧者,圣人之勇也！所以我们要做到战略上藐视它，战术上重视它！你要心理默念Bug其实挺(T)美(M)的(D)!anyway 无Bug不生活！！&lt;/p&gt;

&lt;h2 id=&quot;抽刀断bug&quot;&gt;抽刀断Bug&lt;/h2&gt;

&lt;p&gt;断点，（我求你们不要想到张敬轩，阿轩他容易么，小受又怎么了？你们这帮人真是的！！），我要说的断点是BreakPoint！基本上不是残废的IDE都具有断点调试功能吧！尤其是XCode，我们家的IDE断点调试功能可是强中又是强中手！在这之前大家可以先了解一下哈子是断点？它怎么实现的？工作原理怎么样的？博主就献丑说说自己的理解吧，断点，顾名思义就是从前有一个点，后来它断了，谢谢，我的故事讲完了。哎哟还不服，这些基础常识的东西自己不会查？你还真的脸皮厚上天了去了，还要博主给你查哟，自己查去！&lt;/p&gt;

&lt;h3 id=&quot;普通操作&quot;&gt;普通操作&lt;/h3&gt;

&lt;p&gt;如图3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基本的断点操作如下&lt;/p&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic4.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击那个黑列列就创建了一个断点，再次点击就临时取消这个断点(但是不删除)，长按那个断点拖出去就删除了(mac os的系统工程师就是稀饭拖动的快感)，当然也可以右键那个创建的断点，会弹出相应地菜单。&lt;/p&gt;

&lt;p&gt;当然也还可以监视某个变量！&lt;/p&gt;

&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在对象视图中，右键某个对象，点击“Watch ‘XXX’”就完成XXX对象的监视了。&lt;/p&gt;

&lt;p&gt;这里我监视了lab这个UILabel的变量，每当这个变量进行更新它的信息就会被打印到控制台。&lt;/p&gt;

&lt;p&gt;好吧！我们最基本的创建断点的工作已经学会了，Xcode舒服在什么地方呢？就是不分Debug模式和Run模式的，可以说是无缝切换的，你只要没有创建断点，那么就是Run的正常模式，如果创建了断点并且运行到断点处，就自动进入Debug模式咯，不像某EC开头的IDE，控制面板就像开飞机的一样，几万个按钮以为很强大，其实只用了Run和Stop，还有什么Debug模式，App模式……，果然Xcode的优越感在对比中更加强烈了，舒服到极点呀，就像夏天的海风拂过菊花，嗯是的 就是那种感觉！&lt;/p&gt;

&lt;p&gt;我们创建好了断点，运行到断点就自动停下来了，像这样：&lt;/p&gt;

&lt;p&gt;图6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些Debug的最基本操作技能是每一个入门的iOS开发者都要掌握的，应该当成一种本能，就像狗爱吃翔一样(噢 对不起 博主不是歧视狗的意思，博主也养过狗，很二逼但是从不吃翔！真的据我所知它从来不吃翔的，这里只是比喻只是比喻)。&lt;/p&gt;

&lt;h3 id=&quot;全局断点global-breakpoint&quot;&gt;全局断点（Global BreakPoint）&lt;/h3&gt;

&lt;p&gt;有时候在程序出错的时候不能能准确定位到奔溃的那一行代码,而是直接跑到main循环或者Appdelegate里面， 或者会给你这样的提示：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EXEC_BAD_ACCESS：&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;是不是有种想哭的冲动？尼玛~至少给我一些堆栈信息也好呀~……这个时候你千万不要砸鼠标和键盘哦，一切都是主机在运行，你砸鼠标和键盘有什么用呢？应该是踢主机呀~~，现在有了全局断点，娘亲再也不担心你砸鼠标了，你只需要这样：&lt;/p&gt;

&lt;p&gt;图7&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Debug导航面板进行上图的操作，你就建立了全局断点，这样只要遇到错误，debug程序就会自动定位到栈底的信息，也就是你最先出错的代码的那一行，这样你就可以快乐的debug拉~~&lt;/p&gt;

&lt;h3 id=&quot;条件断点condational-breakpoints&quot;&gt;条件断点(Condational Breakpoints)&lt;/h3&gt;

&lt;p&gt;从前有一个游戏，叫做撸啊撸，有些玩家他们知道怎么操作，会放技能会走路，但是他们不知道买装备，玩了一局下来，鞋子小刀都没有买。我为什么讲这个故事呢？因为很多小朋友学东西和玩游戏一样，看完前面的几种调试技能，就以为自己已经屌爆无敌了，其实他们不过是出门不带装备的玩家，如果只是使用了以上的调试技能只能说是低玩，在高大的逼优鸡面前根本就是会被瞬秒的那种，所以学会装备自己才是王道！条件断点，就是学会有的放矢！&lt;/p&gt;

&lt;p&gt;我们来看一段代码&lt;/p&gt;

&lt;p&gt;图8&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你是不是想问博主为何那么风骚，竟然上了Swift了！！我此刻只想吟一首湿：别人笑我太淫荡，我家住在黄鹤楼。&lt;/p&gt;

&lt;p&gt;反正这个年代大家都是吃饱了撑着的，博主也是，所以就学学Swift咯。&lt;/p&gt;

&lt;p&gt;我们如果在一个循环里面使用了断点，如果这个循环执行了100万次，那你的断点要执行那么多次，你不觉得蛋蛋都凉了的忧伤么？所以我们这么做：&lt;/p&gt;

&lt;p&gt;图9&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样只有遍历到c==“H”的时候 断点才会被触发。&lt;/p&gt;

&lt;p&gt;图10&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是不是很棒呢！&lt;/p&gt;

&lt;p&gt;有些童鞋的钛合金狗眼已经看到了编辑断点那里有一个Action的东西，那是什么呢？&lt;/p&gt;

&lt;p&gt;这个是非常强大的，可以在你断点的位置，执行各种操作，比如执行脚本命令，控制台命令(可以制定调试信息自定义保存)、打印信息等，&lt;/p&gt;

&lt;p&gt;博主最喜欢的就是这个Log message啦，简单粗暴！根本就不需要print啊NSLog嘛，直接在断点的Action打印就好了（其实这个是Xcode和调试器结合的高能产物，下面再介绍）。具体可以这样：&lt;/p&gt;

&lt;p&gt;图11&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其实刚刚博主撒谎了，博主最喜欢的Action并不是Log Message，而是Sound，顾名思义嘛，断点射在Bug上，这样遇到断点就会发出声音，听到我自己设置的声音，我就知道是什么Bug了，听声识Bug，呵呵，&lt;code class=&quot;highlighter-rouge&quot;&gt;EXEC_BAD_ACCESS&lt;/code&gt;的错误我设置成了波多野老师的声音，&lt;code class=&quot;highlighter-rouge&quot;&gt;unrecognized selector send to instancd&lt;/code&gt;的错误我设置成了苍老师的…… 不要问我系统怎么没有吉泽明步的声音，我根本就不知道谁是吉泽明步。&lt;/p&gt;

&lt;p&gt;当然还有更加强大的条件断点就是这货啦&lt;/p&gt;

&lt;p&gt;图12&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;添加之后在 Symbol 一栏输入&lt;code class=&quot;highlighter-rouge&quot;&gt; viewDidLoad&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样一来，在程序中所有的 viewDidLoad 方法被调用时都会触发断点。&lt;/p&gt;

&lt;p&gt;图13&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，我们也可以仅仅为特定的某个类的方法添加断点。在 Symbol 一栏输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;[ClassName viewDidLoad] (Objective-C) &lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClassName.viewDidLoad&lt;/code&gt; (Swift) 即可。&lt;/p&gt;

&lt;p&gt;比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;unrecognized selector sent to instance 0xaxxxx&lt;/code&gt; 这种错误，这个instance可以这样快速定位&lt;/p&gt;

&lt;p&gt;图14&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;打印的艺术&quot;&gt;打印的艺术&lt;/h2&gt;

&lt;p&gt;尽管ARC已经让内存管理变得简单、省时和高效，但是在object的life-cycles中跟踪一些重要事件依然十分重要。毕竟ARC并没有完全排除内存泄露的可能性，或者试图访问一个被release的对象。为了这个目的，我们可以很艺术地偷窥对象正在做些什么，想想就好有快感。&lt;/p&gt;

&lt;h3 id=&quot;nslog&quot;&gt;NSLog&lt;/h3&gt;

&lt;p&gt;小伙伴们第一节课学习ViewController的生命周期的时候，老师肯定很猥琐的教了大家，在viewController的每个生命周期的方法中使用了NSLog来偷窥！没错，这样其实就是最简单爆炸的跟踪生命周期的方法了，不过系统自己的NSLog真心有点羸弱，输出的信息太少，根本就不能满足我们的欲望，这里我教大家强化你的Log！！&lt;/p&gt;

&lt;p&gt;可以用下面的这段宏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//A better version of NSLog

define NSLog(format, ...) do { \

fprintf(stderr, &quot;&amp;lt;%s : %d&amp;gt; %s\n&quot;, \

[[[NSString stringWithUTF8String:FILE] lastPathComponent] UTF8String], \

LINE, func); \

(NSLog)((format), ##VA_ARGS); \

fprintf(stderr, &quot;-------\n&quot;); \

} while (0)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于宏的威力 大家可以乱入我的博文&lt;a href=&quot;https://daiweilai.github.io/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/&quot; target=&quot;_blank&quot;&gt;《 iOS中的预编译指令的初步探究》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这样打印出来的东西才像话嘛(其实NSLog的打印是非常低效的，甚至比print低100倍，感兴趣自己翻翻苹果手册咯)。&lt;/p&gt;

&lt;p&gt;使用objc语言(强类型)并且用NSLog打印的时候，常常搞不清楚NSLog(@“%?”,xxx) xxx这种类型该是什么什么类型输出，应该是%d呢还是%@亦或是%f？？？傻傻分不清楚~，所以玩转NSLog你应该要知道以下这几个全局方法！&lt;/p&gt;

&lt;p&gt;图17&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;开启僵尸对象enable-nszombie-objects&quot;&gt;开启僵尸对象(Enable NSZombie Objects)&lt;/h3&gt;

&lt;p&gt;Xcode可以把那些已经release掉得对象，变成“僵尸”，当我们访问一个Zombie对象时，Xcode可以告诉我们正在访问的对象是一个不应该存在的对象了。因为Xcode知道这个对象是什么，所以可以让我们知道这个对象在哪里，以及这是什么时候发生的。&lt;/p&gt;

&lt;p&gt;所以Zombies是你的好基友！他可以让你输出的信息更具体！！&lt;/p&gt;

&lt;p&gt;具体这样做：&lt;/p&gt;

&lt;p&gt;图15&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;自己再试试输出Object的信息咯，是不是很棒呢？&lt;/p&gt;

&lt;p&gt;僵尸只能用在模拟器和OC语言哦~&lt;/p&gt;

&lt;h2 id=&quot;进击的码农&quot;&gt;进击的码农&lt;/h2&gt;

&lt;p&gt;如果说你已经把打印的艺术运用的风生水起了，并且断点的使用可以信手拈来随心所欲，那么你已经在与逼优鸡的对峙中，稳操大部分胜券了，你已经是一个孤高冷艳的程序员了，俯视一切低能的逼优鸡了！但是！面对更强大的敌人——你那秃顶1000°近视牙齿夹着韭菜的有着十年对战逼优鸡的同事面前、以及笑里藏刀眼睛有眼屎但是能用眼神杀死你的面试官…… 对于他们，你还是太弱，你的技能的磨练还太少！所以你必须要进击！！比逼优鸡还要强大的敌人出现了！我们需要更强大的武器。&lt;/p&gt;

&lt;h3 id=&quot;consolelldb-命令&quot;&gt;Console(lldb 命令)&lt;/h3&gt;

&lt;p&gt;我们的目标是要武装到鼻毛！console窗口大家知道就是哪个黑乎乎好多字会滚出来，尤其是被逼优鸡干到的时候，那么同学们有没有遇到这种console呢&lt;/p&gt;

&lt;p&gt;图16&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们家的编译器历史 敬请乱入 《iOS中的预编译指令的初步探究》 ，没错我们现在正在使用着世界上最好的c、c++、oc、swift的编译器——LLVM,lldb就是这个世界上最好的LLVM的调试器！不要害羞，因为我们是最优秀的！所以肯定要用最好的！千万别客气哟，随便用，就像自己家一样啊，啊 哈哈 吃吃吃 别只顾着吃饭，多夹菜……哎~博主好客的职业病又犯了~，什么？你不知道在哪里用lldb？&lt;/p&gt;

&lt;p&gt;首先！你得先crash或者把程序断下来！直到你看到图16的(lldb)字样出现，你就可以敲命令了~~&lt;/p&gt;

&lt;p&gt;每次你想查看变量，常量，你要重新写NSLog去打印，然后重新编译，去执行，重头开始？太累了，有了lldb你只要这样&lt;/p&gt;

&lt;p&gt;图18&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是不是方便到爆炸？&lt;/p&gt;

&lt;p&gt;当你有一个switch语句，你为了测试每一个case，你都要制造假条件去测试；有一个if…else…语句，你为了测试不同的情况，你要硬编码写了不同的情况，编译好几次为了测试每种情况……，我想你应该知道为什么自己的头发那么稀疏了。&lt;/p&gt;

&lt;p&gt;以上的这些情况，只需一次编译，使用lldb的thread命令，伪造返回值，欺骗寄存器，就可以随心所欲的做完所有测试了。&lt;/p&gt;

&lt;p&gt;是不是牛逼到爆炸？&lt;/p&gt;

&lt;p&gt;lldb真的很强大，博主没有骗你，这篇博文到此的所有调试技巧lldb都可以实现，各种断点，各种打印，调用python插件，运行中断，操作硬件底层，控制程序运行线程……lldb都可以做到！仿佛lldb就是另一个强大的世界！！！&lt;/p&gt;

&lt;p&gt;是不是强大到爆炸？&lt;/p&gt;

&lt;p&gt;其实如果你不想贪多嚼不烂的话，你只要精通这个调试工具，基本前面的调试技能你可以不用学了，在这里博主也是不才，lldb的强大不是博主随便说几句就可以表达的出来的，&lt;/p&gt;

&lt;p&gt;更多地需要大家事必躬亲，才能真正体会到那种美好，那种畅快无比的调试体验！&lt;/p&gt;

&lt;p&gt;这里博主无私地掏出任意门，这里有很好的文章！可以让你好好的回味，呵呵&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://lldb.llvm.org/tutorial.html&quot; target=&quot;_blank&quot;&gt;《The LLDB Debugger》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html&quot; target=&quot;_blank&quot;&gt;《About LLDB and Xcode》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/&quot; target=&quot;_blank&quot;&gt;《LLDB调试命令初探》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://objccn.io/issue-19-2/&quot; target=&quot;_blank&quot;&gt;《与调试器共舞 - LLDB 的华尔兹》&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;profileinstruments&quot;&gt;Profile(instruments)&lt;/h3&gt;

&lt;p&gt;图19&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个东西怎么翻译呢？我们就叫检查器吧！！也许已经学习了iOS开发大半年的你，从来都没注意到或者使用这个工具，但是博主很负责任的告诉你现在市面上任何一款出色的APP都会使用instruments来让代码更加健壮！难道instrument是春药？怎么会使代码健壮呢？&lt;/p&gt;

&lt;p&gt;这个健壮不是那个健壮~哎~~ 我才18岁能不能清纯一点呀&lt;/p&gt;

&lt;p&gt;instrument里面包含了很多工具，内存溢出分析，性能分析，各种分析…… 如果细说的话，这个真的可以为每个工具开一篇博客，但是博主是一个懂得授人以鱼不如授人以渔的道理的老司机！所以博主当然不会全部说一遍！我们就来领着大家看看专用debug的内存溢出分析工具的使用吧！&lt;/p&gt;

&lt;p&gt;图20&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在使用leaks之前大家可以试试这个“Analyze”&lt;/p&gt;

&lt;p&gt;图21&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;analyze可以快速的发现你的代码中release的问题，以及继承过程中的父类方法缺失等等问题！一般一个优秀的iOS开发工程师No Warning、Pass Analyze是最基本的操守！我知道你已经对于你自己的项目的上百个warning已经麻木了，但博主我负责人地告诉你，这样不好！，因为有一首云南民歌《老司机带带我》听得博主神清气爽！&lt;/p&gt;

&lt;p&gt;坚守作为iOS开发者的贞操！跟着我高喊口号！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;No Warning！Pass Analyze！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们继续回来使用leaks！如果analyze都通过了，那么就可以使用leaks工具，发现千年老妖级别的侧漏了！&lt;/p&gt;

&lt;p&gt;图22&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果提示某一个对象有侧漏的风险，你还可以这样弹出侧边的拓展细节&lt;/p&gt;

&lt;p&gt;图23&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接点击方法就可以直接进入代码部分了！！&lt;/p&gt;

&lt;p&gt;是不是很简单粗暴呢！当然还很多其他工具，不过叫做篇幅的东西总是限制人，诶 真蛋疼~真的还想多说点的&lt;/p&gt;

&lt;p&gt;想要更多了解instrument 大家可以看看这篇文章！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode&quot; target=&quot;_blank&quot;&gt;《How to Use Instruments in Xcode》&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;xcode视图调试&quot;&gt;Xcode视图调试&lt;/h3&gt;

&lt;p&gt;有时候有些逼优鸡隐藏的比较深，代码几乎都翻了个遍，还是没找到问题出在哪，博主可以理解那种风中凌乱，蛋碎一地的赶脚，因为无数个日夜博主就是深陷当中无法自拔，后来干脆直接重新新建一个工程！还是不行！！我去，直到有一天博主早上起来，看到镜子中自己帅气的脸庞，我才突然顿悟，原来长得帅可以那样快速的找到bug！最终锁定是可爱又可恨的xib和storyboard出了问题！！某个constraint或者view的嵌套逻辑又或者团队协作Git冲突等等问题，导致io -v什么的错误，这种情况去检查视图文件，可能xcode崩溃打不开那个xib或者storyboard，你直接使用文本工具打开这个xml类型的标记文件，你差点吐血，几万行的记录狗眼都看瞎了……。&lt;/p&gt;

&lt;p&gt;但是这个历史要被终结！！因为我们强大的xcode的视图调试功能！！&lt;/p&gt;

&lt;p&gt;以下内容，完全copy，如有不适，坚持看完！请叫我快乐的搬运工！&lt;/p&gt;

&lt;p&gt;抄袭自&lt;a href=&quot;http://code.tutsplus.com/tutorials/view-debugging-in-xcode-6--cms-22530&quot; target=&quot;_blank&quot;&gt;《View Debugging in Xcode 6》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;苹果在Xcode 6中做了不少明显的改善和优化，视图调试就是其中之一。通常，App用户界面的行为不会符合开发者期望的那样，比如或者不展示视图，或者没有正确地展示。本文讲解如何使用Xcode的新的视图调试功能来简化开发者对问题界面的确认和修复。&lt;/p&gt;

&lt;p&gt;1.Demo 工程&lt;/p&gt;

&lt;p&gt;开始之初先从github（https://github.com/tutsplus/ViewDebugging）上下载示例工程并打开ViewDebugging.xcodeproj。该工程包含一个简单的包含少数视图控制器的可点击的应用程序、应用程序委托以及一个storyboard。该app是为iPhone而设计，但受益于iOS 8的自适应布局,所以界面展示在任何设备上都没有问题。&lt;/p&gt;

&lt;p&gt;您刚刚下载的应用程序示例工程是一个简单的to-do list应用程序，包含可查看其他信息的简单屏幕，比如该示例工程中的项目数，用户头像以及@***的推特操作。点击Xcode左上角的运行按钮将展示在iOS模拟器中运行的应用程序。&lt;/p&gt;

&lt;p&gt;图24&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很快会注意到用户界面中存在问题-表视图中没有展示任何数据。在工程导航面板中打开&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstViewController.swift&lt;/code&gt;并找到以下代码：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mockNotesDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Do some laundry&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Finish homework&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Walk the dog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Learn about view debugging&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;didSet&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reloadData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;mockNotesDataSource&lt;/code&gt;变量是表视图的数据源。使用Swift的属性观察者功能，在数据源发生改变时，表视图会自动重新加载。通过查看以上代码片段，你会发现应该应用中应该有4个项目需要展示，但现在不展示数据就说明某些地方出现了差错。&lt;/p&gt;

&lt;p&gt;启用视图调试&lt;/p&gt;

&lt;p&gt;问题似乎与用户界面有关。运行app过程中，按下底部的Debug View Hierarchy 按钮，或者从菜单中选择Debug &amp;gt; View Debugging &amp;gt; Capture View Hierarchy 来启动视图调试。&lt;/p&gt;

&lt;p&gt;图25&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动视图调试后，Xcode会对应用程序的视图层次拍一个快照并展示三维原型视图来探究用户界面的层级。该三维视图除了展示app的视图层次外，还展示每个视图的位置、顺序和视图尺寸，以及视图间的交互方式。&lt;/p&gt;

&lt;p&gt;示例工程在Xcode中的三维视图展示正常，但表视图单元格似乎有点太宽了。&lt;/p&gt;

&lt;p&gt;图26&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;暂停应用程序调试并在左侧选中Main.Storyboard来修复问题。点击表视图并选中Editor &amp;gt; Resolve Auto Layout Issues &amp;gt; Reset to Suggested Constraints.&lt;/p&gt;

&lt;p&gt;图27&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编译并再次运行应用程序以确定用户界面展示正常。点击Debug View Hierarchy按钮更进一步了解视图调试的功能。&lt;/p&gt;

&lt;p&gt;视图调试功能&lt;/p&gt;

&lt;p&gt;点击并拖拽三维渲染图的任意一边，可旋转或者倾斜用户界面，向左或者向右倾斜可选中某个表视图。&lt;/p&gt;

&lt;p&gt;选中后，Xcode会高亮该视图，并在会在右边展示Object 和Size检查器。查看在跳转栏顶部并确认UITableView是右边最后一个项目。&lt;/p&gt;

&lt;p&gt;图28&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Object 和 Size检查器包括大量有用的信息。过去开发者需要依赖日志语句或者断点来检查视图的配置。&lt;/p&gt;

&lt;p&gt;打开右边的Size inspector（规格检查器），下方是Auto Layout，可以看到视图上已经应用了正确的约束。在Object inspector中，我们可以检查所选视图的属性。&lt;/p&gt;

&lt;p&gt;图29&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Xcode的调试区有9个视图调试过程中要用到的按钮和滑块儿。&lt;/p&gt;

&lt;p&gt;图30&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从左到右控件排序：&lt;/p&gt;

&lt;p&gt;调整视图间距：调整不同视图间的间距。&lt;/p&gt;

&lt;p&gt;展示被剪切的内容：当前展示视图中被剪切的部分。&lt;/p&gt;

&lt;p&gt;展示约束：展示选中视图的约束。&lt;/p&gt;

&lt;p&gt;重置查看区域：将3D渲染透视图恢复至默认状态。&lt;/p&gt;

&lt;p&gt;调整查看模式：选择性地展示3D渲染透视图，比如仅展示内容，仅展示框架以及同时展示内容和框架。&lt;/p&gt;

&lt;p&gt;缩小：缩小3D渲染透视图&lt;/p&gt;

&lt;p&gt;恢复：将3D渲染透视图恢复至默认尺寸。&lt;/p&gt;

&lt;p&gt;放大：放大3D渲染透视图&lt;/p&gt;

&lt;p&gt;调整可视视图范围：隐藏视图或展示视图，一步步解析3D渲染视图，向左或者向右滑动滑块儿有相反的效果。&lt;/p&gt;

&lt;p&gt;建议花一点时间上手操作下这些空间，并理解各自的用处。&lt;/p&gt;

&lt;p&gt;视图层排序&lt;/p&gt;

&lt;p&gt;再次编译和运行应用程序，并点击用户界面底部的”More”标签。第一眼看去界面看起来还OK，但是它没有按照开发者的定义准确执行，图片上的模糊效果没有展示出来。我们可以通过调试视图层次来更好地确定问题所在。&lt;/p&gt;

&lt;p&gt;向左或者向右拖拽视图来查看具体情况，接着将view spacing slider向右拖动。&lt;/p&gt;

&lt;p&gt;图31&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样一来，不同视图间的间距变大了，层次也更加清晰，我们看到在图片”下方”还隐藏着另一个视图，选中隐藏的视图，它就是”丢失”的视觉效果视图。&lt;/p&gt;

&lt;p&gt;图32&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开Main.storyboard 并选中Second View Controller Scene。在左侧的文档概览面板中，展开Second View Controller的视图对象以查看子视图的排序。&lt;/p&gt;

&lt;p&gt;Xcode在文档概览中按照递升顺序堆叠视图，换句话说，列表顶层的视图是视图层次的基础。&lt;/p&gt;

&lt;p&gt;修复问题很简单。运行时，Blur Effect View隐藏在Sky Image之下，因为它是视图层次的第一个视图。在文档概览中点击并拖拽 Blur Effect View，结果会如下图展示一样：&lt;/p&gt;

&lt;p&gt;图33&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再次运行应用程序就能看到模糊效果了。应用程序的用户界面看起来符合设计的初衷。我们还可以查看iOS模拟器的其他调试功能，看看还完善了其他什么地方或功能。&lt;/p&gt;

&lt;p&gt;5.iOS模拟器调试功能&lt;/p&gt;

&lt;p&gt;编译并运行应用程序，选中模拟器，从 Debug菜单中选择Color Blended Layers选项。&lt;/p&gt;

&lt;p&gt;图34&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后会看到app的用户界面被红色和绿色覆盖，显示了哪些图层可以被叠加覆盖，以及哪些图层是透明的。混合层属于计算密集型视图，所以推荐尽可能地使用不透明的图层。&lt;/p&gt;

&lt;p&gt;图35&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic35.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;苹果在其文档（iOS Simulator User Guide）中对此进行了注明，并在表视图处理上使用了不透明图层。滚动视图时会有些表现不大好的地方，一个重要的原因就是使用了混合图层，而如果内容背景是不透明层，那么页面滚动效果就会非常流畅和平稳。&lt;/p&gt;

&lt;p&gt;对于这款应用程序来说，假使用户有数百个项目要展示，可能会出现滚动性能不一致的情况。表视图单元格当前使用的是混合层。由于视图控制器的视图背景是白色，所以不管表视图单元格使用的是混合层或者不透明层，终端用户不会觉察到有什么不一样。&lt;/p&gt;

&lt;p&gt;打开Main.storyboard并选中To Do list Scene中的表视图单元格属性。在属性检查器（Attributes Inspector）中，向下滚动Drawing分区并勾选Opaque。&lt;/p&gt;

&lt;p&gt;图36&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在启用Color Blended Layers的状态下编译并运行应用程序。由于表视图单元格现在使用了不透明层，所以会用绿色覆盖，以指示它们是不透明的。&lt;/p&gt;

&lt;p&gt;除了标记图层外，还有其他一些有用的功能可帮开发者在iOS模拟器中调试应用。以下是其中一些比较有用的：&lt;/p&gt;

&lt;p&gt;Toggle Slow Animations in Frontmost App: 选中模拟器，打开Debug菜单选中Toggle Slow Animations in Frontmost App，该功能可以降低app中动画的运行速度，适合调试包含复杂动画的应用程序。也可是使用快捷键Command-T来操作。&lt;/p&gt;

&lt;p&gt;Color Copied Images:该选项可以给绘制时被Core Animation复制的图片添加蓝绿色叠加层。&lt;/p&gt;

&lt;p&gt;Color Misaligned Images:如果图片边界没有与目标像素完美对齐，该功能可为图片叠加上一层品红色。如果图片使用确定的比例大小绘制，那么该功能会为图片添加一层黄色叠加。&lt;/p&gt;

&lt;p&gt;Color Off Screen Rendered:.该选项为离屏渲染内容添加一个黄色的叠加层。&lt;/p&gt;

&lt;p&gt;很多开发者会忽略接入电话时应用状态栏的设计问题，你可以通过触发通话中状态栏来简单测试。在iOS模拟器中，从Hardware菜单中选中Toggle In-Call Status Bar。&lt;/p&gt;

&lt;p&gt;想查看app如何响应事件，可按下Command-T来启用slow animations，并按下Command-Y来展示电话接入时的状态栏。倘若你的应用程序使用了导航栏，那么操作系统会为你兼顾到这一块儿。&lt;/p&gt;

&lt;p&gt;图37&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-4-13-pic37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了给视图着色外，还要记住iOS模拟器也可以调试Core Location问题。你可以在特定经纬度模拟设备，&lt;/p&gt;

&lt;p&gt;如果你的应用程序使用iCloud来管理数据，你也可以手动触发同步事件。&lt;/p&gt;

&lt;p&gt;本文中使用的demo app非常简单，使用文中提到的技术可以帮你在未来节省不少时间。视图调试可以帮你修正很多用户界面中出现的问题。&lt;/p&gt;

&lt;p&gt;除了Xcode和InterfaceBuilder之外，使用iOS模拟器的调试功能可以提升应用性能和识别开发过程中的瓶颈。苹果的人机交互指南（中文版 英文版）强调了积极响应对app的重要性，能让用户觉得应用易于使用和操作。苹果对InterfaceBuilder的提升让视图调试变得前所未有的简单。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;这篇文章博主花了3个礼拜，断断续续才写完的，当中错漏应该非常多，但是无论如何鄙人觉得应该算是配的上豪华套餐的称号了，当中iOS开发的基本、常用以及高阶的调试技能都涉及了，但是仍然有很多其他的奇门巧技没有介绍到，主要是可恶的“篇幅”限制住了博主广博的爱，但是无论如何，这篇文章大家暂且可以当做是一个调试技术的目录，因为博主在这里写的讲的很粗浅，你不应该只满足于这篇文章，你如果想要改变世界的话，你应该借着博主的这篇目录式文章深入地学习与研究！&lt;/p&gt;

&lt;p&gt;当然还有Crash的日志、测试工程、以及强大牛逼哄哄的第三方调试库等这篇博客没有涉及到，这是一个遗憾，但是我相信聪明的你会去Google一番的！&lt;/p&gt;

&lt;p&gt;还有我们与逼优鸡的故事才刚刚开始。&lt;/p&gt;

</description>
        <pubDate>Mon, 13 Apr 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/04/13/iOS%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/04/13/iOS%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
        
        <category>基础整理</category>
        
        <category>debug</category>
        
        <category>调试</category>
        
        
      </item>
    
      <item>
        <title>封装一个简单实用的朋友圈</title>
        <description>&lt;h1 id=&quot;封装一个简单实用的朋友圈&quot;&gt;封装一个简单实用的朋友圈&lt;/h1&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;2014年过的那么快，过年又那么块，2015年又是飞快地节奏，真尼玛感觉上帝是不是无聊使用了变速外挂开启了加速模式~到现在博主都无法接受已经上班的事实……在地铁脸被挤在玻璃上的时候只能用眼神写满傻X射这个世界一脸！！原谅博主那么鸡粪~因为哥最近生病了，不嗨心~，我想来去想不明白，博主每周健身4天，胸肌压女友、拳头比沙煲、吃喝健又康、体硬似野马，怎么会生病呢？我苦思多日，终于有一天早上起床看了镜子半个小时后我才顿悟，我靠~原来长得帅真的是错！上帝在嫉妒我才让我生病的~哈哈哈 咳咳~这是一个严肃的技术博客~是绝对拒绝恶俗低下的内容的，大丈夫应该心系天下才对，最近柴静和雾霾真的触动了我们每个人的心；某极端组织像嗨大了一样，真的是屠龙宝刀在手，装备任爆的节奏；近下的港岛撑完雨伞又要赶人了……我真的是非常痛心疾首，维护世界和平一直是鄙人的愿望，现在的世界这么混乱，本人真的很惭愧，都怪我咯~~没有因为什么，所以今天博主要教大家怎么写一个自己用着安逸，修改巴适，他人用起来又无比舒服的iOS库！！&lt;/p&gt;

&lt;h2 id=&quot;脑洞开一开&quot;&gt;脑洞开一开&lt;/h2&gt;

&lt;p&gt;本人不才，接触代码的世界时间真心不是很久，对于系统底层优化、框架级别设计、设计模式的效率优劣等方面的学习和研究比不深刻，所以如果你是大神，你狠溜的话，我还是建议您路过呵呵一下然后就关了这个网页吧，雕虫小技无法入尔法眼啊~我不是怕被喷很菜（反正都被老师喷了二十年了……^_^）而是我对大神都是有敬畏之心的，不能说让你看你就看，你可以试一下是吧，你也不喜欢看完后是Duang 那么多特效 特技……咳咳 反正这篇文章真的很菜~~~适合比我菜的菜鸟，慎读。&lt;/p&gt;

&lt;p&gt;不过嘛我们要写一个库，能够让别人用，用起来要很舒服的，那肯定得要设计得当，肯定要熟悉平台，设计模式非常溜才行，这个没错~但是平台、架构、设计这个东西这么复杂，我解释大家也不懂，那我就不解释了（你强迫症发作死都要懂可自行找一个大学，里面有老师~）&lt;/p&gt;

&lt;p&gt;我发誓不扯BB了 我们一起来写一个能被舒服舒服又舒服地调用的iOS库，最近卫生纸涨价了，好烦，其实也是有原因的，因为毕竟生产费用什么的也都…我头上的砖头谁扔的！！？？信不信我不打死你丫的……&lt;/p&gt;

&lt;p&gt;假设我们要开发一个像微信朋友圈或者微博这玩意儿的东西，并且要有能隐藏和展开正文、正文中能够识别富文本（网址、电话、@姓名……）、还要有图片缩略图而且点击查看、能够有回复、回复文中也要支持富文本……这些功能。像这样&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-3-15-pic1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所谓君子生非异也 善假于物也。上面的功能这么多这么复杂自己写，你确定你不是吃饱了撑着？经理也说要敏捷开发，所以二话不说闪现到code4app，code.cocoachina祭出最强杀器——搜索引擎，找到了这个库&lt;a href=&quot;https://github.com/TigerWf/WFCoretext&quot; target=&quot;_blank&quot;&gt;WFCoretext&lt;/a&gt;  发现它完美符合我们的需求呀，棒棒哒&lt;/p&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;首先我们感谢WFCoretext 的作者的开源贡献，请收下我的膝盖，我们马上来用一用~&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-3-15-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;槽点不多&lt;/p&gt;

&lt;p&gt;我们来分析分析它怎么搞得把&lt;/p&gt;

&lt;p&gt;工程结构 图3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-3-15-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;嗯额 还是比较简单的 View文件夹里面的是控件啦&lt;/p&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-3-15-pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体实现 大家可以自己看啦，这位哥哥代码风格还是比较规范的，看起来不费劲&lt;/p&gt;

&lt;p&gt;Manager文件夹中是一些富文本匹配规则，其中YMTextData很重要 下面说&lt;/p&gt;

&lt;p&gt;我们直接来看看怎么使用的把&lt;/p&gt;

&lt;p&gt;点开&lt;code class=&quot;highlighter-rouge&quot;&gt;WXViewController&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;导包并且声明变量，变量在实现接下来的实现中会进行初始化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#import &quot;WXViewController.h&quot;
#import &quot;YMTableViewCell.h&quot;
#import &quot;ContantHead.h&quot;
#import &quot;YMShowImageView.h&quot;
#import &quot;YMTextData.h&quot;
#import &quot;YMReplyInputView.h&quot;

#define dataCount 10
#define kLocationToBottom 20
#define kAdmin @&quot;小虎-tiger&quot;


@interface WXViewController ()&amp;lt;UITableViewDataSource,UITableViewDelegate,cellDelegate,InputDelegate&amp;gt;
{
NSMutableArray *_imageDataSource;

NSMutableArray *_contentDataSource;//模拟接口给的数据

NSMutableArray *_tableDataSource;//tableview数据源

NSMutableArray *_shuoshuoDatasSource;//说说数据源

UITableView *mainTable;

UIButton *replyBtn;

YMReplyInputView *replyView ;
}
@end  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个方法分别构建初始化了一个tableview，初始化并赋值图片数据，初始化并赋值其他数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;- (void) initTableview;
- (void)configImageData;
- (void)loadTextData;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;loadTextData中&lt;/code&gt;会将数据包装成YMTextData的数组，这样一个tableCell里面的数据就使用一个YMTextData的数据&lt;/p&gt;

&lt;p&gt;然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)calculateHeight:(NSMutableArray *)dataArray&lt;/code&gt;中会计算出数据所占用view的高度 这里面也就实现了 我们需求里面可以扩展可以收缩的功能&lt;/p&gt;

&lt;p&gt;计算完高度然后就重新加载tableview了 然后tableview的各种delegate方法 各种datasource方法就呼呼的运行了&lt;/p&gt;

&lt;p&gt;其中 以下方法中又再次使用了我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)calculateHeight:(NSMutableArray *)dataArray&lt;/code&gt;方法中计算出来的高度来设置tablecell的高度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
YMTextData *ym = [_tableDataSource objectAtIndex:indexPath.row];
BOOL unfold = ym.foldOrNot;
return TableHeader + kLocationToBottom + ym.replyHeight + ym.showImageHeight + kDistance + (ym.islessLimit?0:30) + (unfold?ym.shuoshuoHeight:ym.unFoldShuoHeight) + kReplyBtnDistance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下这个方法又把YMTextData 赋值给了YMTableViewCell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
static NSString *CellIdentifier = @&quot;ILTableViewCell&quot;;
YMTableViewCell *cell = (YMTableViewCell *)[tableView dequeueReusableCellWithIdentifier:CellIdentifier];
if (cell == nil) {
cell = [[YMTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
}
cell.stamp = indexPath.row;
cell.replyBtn.tag = indexPath.row;
cell.replyBtn.appendIndexPath = indexPath;
[cell.replyBtn addTarget:self action:@selector(replyAction:) forControlEvents:UIControlEventTouchUpInside];
cell.delegate = self;
[cell setYMViewWith:[_tableDataSource objectAtIndex:indexPath.row]];
return cell;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;阿拉巴拉…… 呼呼&lt;/p&gt;

&lt;p&gt;我就想问你一句 累不累？&lt;/p&gt;

&lt;p&gt;现在我分析了一遍这个库，你知道该怎么用了么，不要怀疑自己的智商，我也要再看一遍才知道怎么用。&lt;/p&gt;

&lt;p&gt;当然我们不能怀疑作者对于开源技术做出的贡献！我们也不能怀疑作者的开发技术，毕竟这个库的bug还是比较少的，作者是伟大崇高的！减少了世界的碳排量方便了你我他，为很多代码工作者提供了方便，让他们可以不加班，早早的回家陪老婆陪基友陪孩子陪宠物……所以我要再次感谢作者&lt;/p&gt;

&lt;p&gt;但是作为一个有完美强迫症的博主，问自己一句 为什么这个库那么难用？因为它难用&lt;/p&gt;

&lt;p&gt;怎么才算是好用？系统自带的组件，使用和学习起来那么容易？这应该算是好用吧。&lt;/p&gt;

&lt;p&gt;所以接下来，我们要开刀WXViewController 让他DUANG的一下，变得使用起来 舒服舒服又舒服！！&lt;/p&gt;

&lt;h2 id=&quot;整容&quot;&gt;整容&lt;/h2&gt;

&lt;p&gt;我们不妨WXViewController的实现细节都封装起来！它是一个tableview、它怎么计算高度，它的回复按钮怎么生成……巴拉巴拉我都不想管！！我的愿望是，我只要扔进去数据，就自动生成一个朋友圈出来！！！！&lt;/p&gt;

&lt;p&gt;有了愿望，急着召唤神龙也没用！规则是要集齐龙珠呀！！！好我们先干起来！整容WXViewController！！！&lt;/p&gt;

&lt;p&gt;我们要开发一个东西就叫做 “朋友圈模板”吧 在“朋友圈模板.h”中要有一个“朋友圈模板Delegate” 然后里面要有一个方法&lt;code class=&quot;highlighter-rouge&quot;&gt;-(返回的数据*)每行朋友圈的数据:index;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们使用的时候就这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//真朋友圈.h

@interface 真朋友圈 : 朋友圈模板&amp;lt;朋友圈模板Delegate&amp;gt; 
@end
真朋友圈.m

@implementation 真朋友圈
- (void)viewDidLoad {
self.delegate = self;
}

-(返回的数据*)每行朋友圈的数据:index{
return [朋友圈数据数组 objectAtIndex:index];
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就好了！你就再也不用关心朋友圈怎么实现了 你只要关系你的数据部分！！就问你Nice不Nice？？？&lt;/p&gt;

&lt;p&gt;所以这里只要你开发好了“朋友圈模板.m”那么以后“朋友圈模板.h”和“朋友圈模板.m”就是你写好的能被人舒服舒服又舒服调用的库了！酷不酷？？&lt;/p&gt;

&lt;p&gt;博主就手把手教你怎么写这个“朋友圈模板.m”吧 嘻嘻嘻 手把手哦 呵呵呵 手 把 手哟 博主是很有爱的哦~~~~&lt;/p&gt;

&lt;p&gt;我们要开发一个&lt;code class=&quot;highlighter-rouge&quot;&gt;DDRichTextViewController&lt;/code&gt;来代替&lt;code class=&quot;highlighter-rouge&quot;&gt;WXViewController&lt;/code&gt; &amp;lt;——这个太难用了&lt;/p&gt;

&lt;p&gt;我们先来写写&lt;code class=&quot;highlighter-rouge&quot;&gt;DDRichTextViewController.h&lt;/code&gt;嘛&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//学学系统组件 我们也来弄一个delegate和datasource~ 其实都是delegate为了更好地区分功能，datasource主要用来设置数据有关

@protocol DDRichTextViewDelegate 
@required
-(NSString*)senderName;//必须要实现！不然评论别人的时候没名字 最恨匿名渣渣，自己叫的名字都不敢直接说！！“有谁知道我买充气娃娃都匿名呢 呵呵，啊？为什么我心里想的会变成文字显示出来！！！纳尼！！”
@optional
-(BOOL)hideReplyButtonForIndex:(NSInteger)index;//是否隐藏回复按钮，有时候我们不让人回复 就把回复按钮隐藏起来了
-(void)didPromulgatorPressForIndex:(NSInteger)index name:(NSString*)name;//发布者的头像或者名字被点击
-(void)didRichTextPressedFromText:(NSString*)text index:(NSInteger)index;//正文的富文本被点击的回调
-(void)didRichTextPressedFromText:(NSString*)text index:(NSInteger)index replyIndex:(NSInteger)replyIndex;//评论的富文本被点击的回调
-(void)replyForIndex:(NSInteger)index replyText:(NSString*)text;//回复文字的内容的回调
@end


@protocol DDRichTextViewDataSource 
@required
-(YMTextData*)dataForRowAtIndex:(NSInteger)index;//这个就是每行需要的数据了！
-(NSInteger)numberOfRowsInDDRichText;//需要返回多少行
@end

@interface DDRichTextViewController : UIViewController&amp;lt;UITableViewDataSource,UITableViewDelegate,cellDelegate,InputDelegate&amp;gt;
@property (weak, nonatomic) id delegate;
@property (weak, nonatomic) id dataSource;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DDRichTextViewController.m&lt;/code&gt;了&lt;/p&gt;

&lt;p&gt;基本上就是对&lt;code class=&quot;highlighter-rouge&quot;&gt;WXViewController.m&lt;/code&gt;的封装了！ 让其内部实现的细节都对使用者透明化&lt;/p&gt;

&lt;p&gt;比如在&lt;code class=&quot;highlighter-rouge&quot;&gt;DDRichTextViewController&lt;/code&gt;中实现了uitableView的datasource和delegate&lt;/p&gt;

&lt;p&gt;在这个方法中 tableview需要显示的行数就由继承&lt;code class=&quot;highlighter-rouge&quot;&gt;DDRichTextViewController&lt;/code&gt;的子类的datasource中的&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-(NSInteger)numberOfRowsInDDRichText;&lt;/code&gt;这个方法返回的数据作为参数！&lt;/p&gt;

&lt;p&gt;比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{
return [[self dataSource] numberOfRowsInDDRichText];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以当我们使用我们自己写的库的时候根本不在乎这个方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView；&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为我们封装到了&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-(NSInteger)numberOfRowsInDDRichText;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;类似其他实现以及方法都进行了封装&lt;/p&gt;

&lt;p&gt;这当中处理@required很简单，用户必须已经实现了 所以直接调用就好 。 但是 @optional的方法用户不一定会去实现，所以当中最重要的就是要去判断这个方法存不存在：方法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt; respondsToSelector:NSSelectorFromString(@“方法名:”) //这个凡是继承NSObject的类都拥有这个方法 这个是基础了，是运行时判断方法存不存在的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;if ([self.delegate respondsToSelector:NSSelectorFromString(@&quot;hideReplyButtonForIndex:&quot;)]) { //判断hideReplyButtonForIndex方法存不存在 存在才会执行如下的代码
if ([[self delegate] hideReplyButtonForIndex:indexPath.section]) {
cell.hideReply = YES;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是详细的代码&lt;/p&gt;

&lt;p&gt;（本来想贴详细代码的，博主一思忖！最好下载我的Demo进行研究 这样可以在方法之间跳转 更能看得懂！！地址在文后！而且你们在博主的Demo项目中star一下 我就爱死你Y的了）&lt;/p&gt;

&lt;p&gt;最后我们来看看怎么使用写好的&lt;code class=&quot;highlighter-rouge&quot;&gt;DDRichTextViewController&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;TestViewController&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//TestViewController.h

#import &quot;DDRichTextViewController.h&quot;
@interface TestViewController : DDRichTextViewController&amp;lt;DDRichTextViewDataSource,DDRichTextViewDelegate&amp;gt;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
//
// TestViewController.m
//

#import &quot;TestViewController.h&quot;

@implementation TestViewController
NSMutableArray * ymDataArray;

- (void)viewDidLoad {
[super viewDidLoad];
NSMutableArray MyDataArr = [[NSMutableArray alloc]init];//!!!!这里应该自己初始化数据
self.delegate = self;
self.dataSource = self;
}

//下面两个是datasource方法
-(NSInteger)numberOfRowsInDDRichText{
return 5;
}

-(YMTextData *)dataForRowAtIndex:(NSInteger)index{
return [MyDataArr objectAtIndex:0];//!!!!!!!! MyDataArr 是一个YMTextData的数组！！所以你的朋友圈数据的每一项都必须是YMTextData或者继承YMTextData的子类！！
}

//下面所有都是delegate的方法 朋友圈所有的特性都使用以下的delegate方法进行控制 方法有可选和必选的 可自行实现 接口调用简单
-(NSString *)senderName{
return @&quot;David&quot;;
}

-(BOOL)hideReplyButtonForIndex:(NSInteger)index{
return NO;
}

-(void)didPromulgatorNameOrHeadPicPressedForIndex:(NSInteger)index name:(NSString *)name{
UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;发布者回调&quot; message:[NSString stringWithFormat:@&quot;姓名：%@\n index：%d&quot;,name,index] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];
[alert show];
}


-(void)didRichTextPressedFromText:(NSString*)text index:(NSInteger)index{
UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;正文富文本点击回调&quot; message:[NSString stringWithFormat:@&quot;点击的内容：%@\n index：%d&quot;,text,index] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];
[alert show];
}

-(void)didRichTextPressedFromText:(NSString *)text index:(NSInteger)index replyIndex:(NSInteger)replyIndex{
UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;评论的富文本点击回调&quot; message:[NSString stringWithFormat:@&quot;点击的内容：%@\n index：%d \n replyIndex:%d&quot;,text,index,replyIndex] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];
[alert show];
}

-(void)replyForIndex:(NSInteger)index replyText:(NSString*)text{
UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;回复的回调&quot; message:[NSString stringWithFormat:@&quot;回复的内容：%@\n index：%d&quot;,text,index] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];
[alert show];
}

@end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下&lt;/p&gt;

&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-3-15-pic5.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/daiweilai/DDRichText&quot; target=&quot;_blank&quot;&gt; 项目及Demo地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;博主对WXViewController的改动还是颇多的，不单单是简单地封装，我还做了表情和姓名的正则判断，还对YMTableViewCell做了大量的逻辑修改，回调的接口做更改和增添也甚多！需要你亲自去发现博主隐藏的爱，但无论如何这都是潦草的项目，想要正式的使用在企业开发中这还远远不够的！没有进行模块和单元的测试，其中图片的处理方式也不好，这里我是直接要求用户添加Image文件的 这个应该改成 添加图片地址，然后让这个库异步去请求显示的……所以还是需要大家的开源精神和力量去贡献自己的，燃烧自己的，骚年文章结束了&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Mar 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/03/15/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%9C%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/03/15/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%9C%88/</guid>
        
        <category>基础整理</category>
        
        <category>富文本</category>
        
        
      </item>
    
      <item>
        <title>无比迅速敏捷地开发iOS超精美控件</title>
        <description>&lt;h1 id=&quot;无比迅速敏捷地开发ios超精美控件&quot;&gt;无比迅速敏捷地开发iOS超精美控件&lt;/h1&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;自从人生第一篇博客《iOS中的预编译指令的初步探究》问世以来 浏览量竟然达到了360多，（路过的大神勿笑！）这些浏览量使我兴奋异常但又令我黯然神伤，为何我会眼里常含泪水？因为国人伸手党达90%！！！区区只有可怜的三个评论，可怜的三个评论~ 没有鼓励~ 没有鲜花~ 也没有谩骂~ 但是我不哭 因为贱人会笑！我深信：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一日伸手党，bug终身随！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这次的东西标题为《无比迅速敏捷地开发iOS超精美控件》！就问你怕不怕！！本人深恶痛绝标题党丫的，所以今天我就绝对会展示一些奇淫巧技！帅气并且超快的撸出一个iOS精美控件！别说我坑你？&lt;/p&gt;

&lt;p&gt;上图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic1.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个我叫它DDClock，所有view都使用Quartz 2D绘制，创建后自动与当前系统对时同步，漂亮、精致、优雅…… （如果你看到这里，你说不漂亮、不精致、不优雅，那么请你出去，我担心我会下手过重，呵呵），想知道怎么弄得？别急！让博主带你手拿菜刀砍电线，一路火光加闪电！！！&lt;/p&gt;

&lt;h2 id=&quot;设计&quot;&gt;设计&lt;/h2&gt;

&lt;p&gt;在工程界有一个说法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计的优秀与否，是导致这个产品成败的关键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好吧设计先行！想好了再动手！想好了再动手在生活中是很重要，比如小学生和初中生是怎么区分的？区别就是在LOL中他们对技能的施放是否进行周密的思考，所以一些选手一个人直接冲进人堆里，技能啪啪一甩，然后就挂了——小学生！所以嘛，做事情前养成思考的习惯，是脱离小学生群体的重要手段哦~&lt;/p&gt;

&lt;p&gt;前面说到一点，DDClock创建后需要自动与当前系统对时同步；所以&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们不妨让DDClock继承UIView，然后重载&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)drawRect:(CGRect)rect&lt;/code&gt;方法，在这个方法中帅气的画出那个时钟所有细节！我们的决心是坚决不使用人民的一张图片！；&lt;/li&gt;
  &lt;li&gt;然后分析整个DDClock只有指针（时分秒针）和指示上下午的AM、PM会动！所以我们要把这些个东西射成变量！关于指针的运动，我们可以使用定时器，每秒都和系统对时；&lt;/li&gt;
  &lt;li&gt;我们还要支持主题的切换，那就给DDClock定义一个枚举咯；&lt;/li&gt;
  &lt;li&gt;然后就这样…&lt;/li&gt;
  &lt;li&gt;然后就这样这样……&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;哈~ 在我们精细的设计中，这个DDClock的产品形态竟然出乎的饱满，俗话说的好，打铁要趁热，豆腐趁热吃。我们马上祭出杀器XCode！！我知道你现在已经兴奋了&lt;/p&gt;

&lt;h2 id=&quot;编码&quot;&gt;编码&lt;/h2&gt;

&lt;p&gt;我们就新建一个项目 叫做DDClockDemo吧，用来测试待会我们设计的DDClock。&lt;/p&gt;

&lt;p&gt;然后我们就在项目中新建一个Group（文件夹）吧 ，就命名成DDClock嘛~&lt;/p&gt;

&lt;p&gt;再然后嘛，我们就在DDClock的文件夹下新建一个OC对象吧（Cocoa Touch Class）取名字DDClock，让它继承UIView&lt;/p&gt;

&lt;p&gt;Nice！！来看看我们的工程目录结构 图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好！我们要开始写代码咯&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//
//  DDClock.h
//  Created by David on 15/1/26.
//  博客：https://daiweilai.github.io
//  github：https://github.com/daiweilai/
//  Copyright (c) 2015年 DavidDay. All rights reserved.
// 

#import &amp;lt;UIKit/UIKit.h&amp;gt;
#define DDClockSize 200 //默认时钟的长宽都为200
#if ! __has_feature(objc_arc)
#error &quot;需要开启ARC&quot;
#endif

@protocol DDLockDelegate 
@optional
-(UIColor*)rimColor;
-(UIColor*)markColor;
-(UIColor*)faceColor;
-(UIColor*)fontColor;
-(UIColor*)secondHandColor;
-(UIColor*)hourAndMinuteHandColor;
@end


@interface DDClock : UIView
@property (weak, nonatomic) id delegate;
typedef NS_ENUM(NSUInteger, DDClockTheme) { //弄一个枚举类型用来更改主题
    DDClockThemeDefault = 0,
    DDClockThemeDark,
    DDClockThemeModerm
};
//DDClock的构造方法 delegate:代理
-(instancetype)initWithDelegate:(id)delegate frame:(CGRect)frame;
///DDClock的构造方法 theme:主题 
-(instancetype)initWithTheme:(DDClockTheme)theme frame:(CGRect)frame;
@end

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//
//  DDClock.m
//  Created by David on 15/1/26.
//  博客：https://daiweilai.github.io
//  github：https://github.com/daiweilai/
//  Copyright (c) 2015年 DavidDay. All rights reserved.
//

#import &quot;DDClock.h&quot;

@interface DDClock(){
    //// 声明颜色
    UIColor* rimColor;
    UIColor* faceColor;
    UIColor* markColor;
    UIColor* secondHandColor;
    UIColor* fontColor;
    UIColor* hourAndMinuteHandColor;
    DDClockTheme _theme;
    float _scale;
    CGPoint _centerPoint;
}
@end


@implementation DDClock


-(instancetype)initWithDelegate:(id)delegate frame:(CGRect)frame{
    //防止用户在构建的时候传入的height和widt不一样 因为时钟是圆的所以强制把他们变成长宽一样
    CGFloat size = frame.size.height&amp;gt;frame.size.width?frame.size.height:frame.size.width;
    CGRect realRect = CGRectMake(frame.origin.x, frame.origin.y, size, size);
    self = [self initWithFrame:realRect];
    if (self) {
        _scale = realRect.size.height / DDClockSize; //放大缩小的比例系数
        _centerPoint = CGPointMake(size/2, size/2); //中心点
        //先使用默认的颜色初始化 防止用户没有调用delegate方法
        rimColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
        faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
        markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
        secondHandColor = [UIColor colorWithRed: 86.0/255.0 green: 232.0/255.0 blue: 157.0/255.0 alpha: 1];
        fontColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
        hourAndMinuteHandColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];

		//判断用户是否使用了delegate的方法
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;rimColor&quot;)]) {
            rimColor = [delegate rimColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;faceColor&quot;)]) {
            faceColor = [delegate faceColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;markColor&quot;)]) {
            markColor = [delegate markColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;fontColor&quot;)]) {
            fontColor = [delegate fontColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;hourAndMinuteHandColor&quot;)]) {
            hourAndMinuteHandColor = [delegate hourAndMinuteHandColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;secondHandColor&quot;)]) {
            secondHandColor = [delegate secondHandColor];
        }
		
		//秒针使用图片画出来
        UIImage *img = [self drawSecondHandWithColor:secondHandColor scale:_scale frameSize:CGSizeMake(size, size) currentAngle:[self secondAngleFromDate:[NSDate new]]];
        UIImageView *imgV = [[UIImageView alloc] initWithImage:img];
        imgV.frame = CGRectMake(0 , 0, size, size);
        [self addSubview:imgV];

        //1.创建动画并指定动画属性
        CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];

        //2.设置动画属性初始值、结束值
        //    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];//
        basicAnimation.toValue=[NSNumber numberWithFloat:2*M_PI];

        //设置其他动画属性
        basicAnimation.duration=60.0;//60秒转一圈
        basicAnimation.autoreverses=false;//旋转后再旋转到原来的位置
        basicAnimation.repeatCount = CGFLOAT_MAX;//无限循环的执行动画

        imgV.layer.anchorPoint = CGPointMake(0.5, 0.5);//设置秒针的旋转中心 就是这个view的中心！


        //4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取
        [imgV.layer addAnimation:basicAnimation forKey:@&quot;Rotation&quot;];



        //当这个DDClock被创建出来的时候，就新建一个定时器，1分钟执行一次“onTimer”方法 其实这里做是不够好的 因为这样不能确保秒针走到12的时候更新 时针和分针 要想解决也很容易 最近生病 难受 不想解决了~~
        [NSTimer scheduledTimerWithTimeInterval:60.0 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];
    }
    self.backgroundColor = [UIColor clearColor];
    return self;

}


///构造方法 使用默认主题
-(instancetype)initWithTheme:(DDClockTheme)theme frame:(CGRect)frame{
    //防止用户在构建的时候传入的height和widt不一样 因为时钟是圆的所以强制把他们变成一样
    CGFloat size = frame.size.height&amp;gt;frame.size.width?frame.size.height:frame.size.width;
    CGRect realRect = CGRectMake(frame.origin.x, frame.origin.y, size, size);
    self = [self initWithFrame:realRect];
    if (self) {
        _theme = theme;
        _scale = realRect.size.height / DDClockSize;
        _centerPoint = CGPointMake(size/2, size/2);

        switch (theme) { //根据主题绘制不同的颜色
            case DDClockThemeDefault:
                rimColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 86.0/255.0 green: 232.0/255.0 blue: 157.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                break;

            case DDClockThemeDark:
                rimColor = [UIColor colorWithRed: 66.0/255 green: 66.0/255 blue: 66.0/255 alpha: 1];
                faceColor = [UIColor colorWithRed: 66.0/255 green: 66.0/255 blue: 66.0/255 alpha: 1];
                markColor = [UIColor colorWithRed:  1 green: 1 blue: 1 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 32.0/255.0 green: 250.0/255.0 blue: 200.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                break;

            case DDClockThemeModerm:
                rimColor = [UIColor colorWithRed: 60.0/255 green: 90.0/255 blue: 110.0/255 alpha: 1];
                faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 210.0/255.0 green: 0 blue: 10.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 210.0/255.0 green: 0 blue: 10.0/255.0 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 60.0/255 green: 90.0/255 blue: 110.0/255 alpha: 1];
                break;
            default:
                rimColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 86.0/255.0 green: 232.0/255.0 blue: 157.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                break;
        }

        if ([_delegate rimColor]) {
            rimColor = [_delegate rimColor];
        }
        if ([_delegate faceColor]) {
           faceColor = [_delegate faceColor];
        }
        if ([_delegate markColor]) {
            markColor = [_delegate markColor];
        }
        if ([_delegate fontColor]) {
            fontColor = [_delegate fontColor];
        }
        if ([_delegate faceColor]) {
            faceColor = [_delegate faceColor];
        }
        if ([_delegate hourAndMinuteHandColor]) {
            hourAndMinuteHandColor = [_delegate hourAndMinuteHandColor];
        }
        if ([_delegate secondHandColor]) {
            secondHandColor = [_delegate secondHandColor];
        }



        UIImage *img = [self drawSecondHandWithColor:secondHandColor scale:_scale frameSize:CGSizeMake(size, size) currentAngle:[self secondAngleFromDate:[NSDate new]]];
        UIImageView *imgV = [[UIImageView alloc] initWithImage:img];
        imgV.frame = CGRectMake(0 , 0, size, size);
        [self addSubview:imgV];

        //1.创建动画并指定动画属性
        CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];

        //2.设置动画属性初始值、结束值
        //    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];
        basicAnimation.toValue=[NSNumber numberWithFloat:2*M_PI];

        //设置其他动画属性
        basicAnimation.duration=60.0;
        basicAnimation.autoreverses=false;//旋转后再旋转到原来的位置
        basicAnimation.repeatCount = CGFLOAT_MAX;

        imgV.layer.anchorPoint = CGPointMake(0.5, 0.5);


        //4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取
        [imgV.layer addAnimation:basicAnimation forKey:@&quot;Rotation&quot;];



        //当这个View被创建出来的时候，就新建一个定时器，1分钟执行一次“onTimer”方法
        [NSTimer scheduledTimerWithTimeInterval:60.0 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];
    }
    self.backgroundColor = [UIColor clearColor];
    return self;
}

//每秒钟刷新视图一次
-(void)onTimer{
    dispatch_async(dispatch_get_main_queue(), ^{
        [self setNeedsDisplay];//这个方法调用后就会刷新这个View
    });
}

//View刷新这个方法就被调用，就会重新画出这个View
-(void)drawRect:(CGRect)rect{
    [super drawRect:rect];
    //获取当前的时间进行View的绘制
    [self drawDDClockWithScale:_scale centerPoint:_centerPoint currentDate:[NSDate new]];


}

////画出秒针
-(UIImage*)drawSecondHandWithColor:(UIColor*)color scale:(CGFloat)scale frameSize:(CGSize)size currentAngle:(float)currentAngle{
    UIGraphicsBeginImageContext(size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    //// secondHand Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, size.height/2, size.height/2);
    CGContextRotateCTM(context, (currentAngle - 90) * M_PI / 180);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* secondHandPath = UIBezierPath.bezierPath;
    [secondHandPath moveToPoint: CGPointMake(4.96, -4.87)];
    [secondHandPath addCurveToPoint: CGPointMake(6.93, -0.92) controlPoint1: CGPointMake(6.07, -3.76) controlPoint2: CGPointMake(6.73, -2.37)];
    [secondHandPath addLineToPoint: CGPointMake(66.01, -0.92)];
    [secondHandPath addLineToPoint: CGPointMake(66.01, 0.08)];
    [secondHandPath addLineToPoint: CGPointMake(7.01, 0.08)];
    [secondHandPath addCurveToPoint: CGPointMake(4.96, 5.03) controlPoint1: CGPointMake(7.01, 1.87) controlPoint2: CGPointMake(6.32, 3.66)];
    [secondHandPath addCurveToPoint: CGPointMake(-4.94, 5.03) controlPoint1: CGPointMake(2.22, 7.76) controlPoint2: CGPointMake(-2.21, 7.76)];
    [secondHandPath addCurveToPoint: CGPointMake(-4.94, -4.87) controlPoint1: CGPointMake(-7.68, 2.29) controlPoint2: CGPointMake(-7.68, -2.14)];
    [secondHandPath addCurveToPoint: CGPointMake(4.96, -4.87) controlPoint1: CGPointMake(-2.21, -7.61) controlPoint2: CGPointMake(2.22, -7.61)];
    [secondHandPath closePath];
    [color setFill];
    [secondHandPath fill];
    CGContextRestoreGState(context);
    UIImage *img = [UIImage new];
    img = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return img;
}


///把当前的时间转换为时针、分针、角度
-(NSArray*)HourAndMinuteAngleFromDate:(NSDate*)date{
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@&quot;HH&quot;];//强制24小时格式
    float hourf = [[formatter stringFromDate:date] floatValue];
    [formatter setDateFormat:@&quot;mm&quot;];
    float minutef = [[formatter stringFromDate:date] floatValue];
    if (hourf &amp;gt; 12) {//大于24小时我们就减去12小时嘛 比较好算角度呀
        hourf = (hourf - 12)*30 + 30*(minutef/60); //一小时30°
    }else{
        hourf = hourf*30 + 30*(minutef/60);
    }
    minutef = minutef*6;//一分钟6°
    NSNumber *hour =  [[NSNumber alloc] initWithInt:hourf];
    NSNumber *minute = [[NSNumber alloc] initWithInt:minutef];
    NSArray *arr = [[NSArray alloc] initWithObjects:hour,minute, nil];
    return arr;
}

//因为秒针的实时性 所以单独算出当前秒针的角度
-(float)secondAngleFromDate:(NSDate*)date{
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@&quot;ss&quot;];
    float secondf = [[formatter stringFromDate:date] floatValue];
    secondf = secondf*6;//一分钟6°
    return secondf;
}

//绘制图形的主要方法
- (void)drawDDClockWithScale: (CGFloat)scale centerPoint:(CGPoint)centerPoint currentDate:(NSDate*)currentDate;
{
    NSArray *arr = [self HourAndMinuteAngleFromDate:currentDate];
    NSNumber *hourAngle = (NSNumber*)[arr objectAtIndex:0];
    NSNumber *minuteAngle = (NSNumber*)[arr objectAtIndex:1];



    //获取绘图上下文
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// 画出边框
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* rimPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-100, -100, 200, 200)];
    [rimColor setFill];
    [rimPath fill];

    CGContextRestoreGState(context);


    //// 画出钟表盘
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* facePath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-92.99, -92.92, 186, 186)];
    [faceColor setFill];
    [facePath fill];

    CGContextRestoreGState(context);


    //// 上午下午时间的判断
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect aMPMRect = CGRectMake(-15.99, -42.92, 32, 18);
    NSMutableParagraphStyle* aMPMStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    aMPMStyle.alignment = NSTextAlignmentCenter;

    NSDictionary* aMPMFontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 15], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: aMPMStyle};
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@&quot;HH&quot;];//强制24小时格式
    float hourf = [[formatter stringFromDate:currentDate] floatValue];//为了节省系统资源 延迟一分钟才会更新 因为这个方法是一分钟 调用一次的
    NSString *str = hourf&amp;lt;12?@&quot;AM&quot;:@&quot;PM&quot;;
    [str drawInRect: aMPMRect withAttributes: aMPMFontAttributes];

    CGContextRestoreGState(context);


    //// 画出时针
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextRotateCTM(context, [hourAngle floatValue] * M_PI / 180);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* hourHandPath = [UIBezierPath bezierPathWithRect: CGRectMake(-4.99, -52.46, 10, 43.54)];
    [hourAndMinuteHandColor setFill];
    [hourHandPath fill];

    CGContextRestoreGState(context);


    //// 画出分针
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextRotateCTM(context, ([minuteAngle floatValue]) * M_PI / 180);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* minuteHandPath = [UIBezierPath bezierPathWithRect: CGRectMake(-2.99, -64.92, 6, 55.92)];
    [hourAndMinuteHandColor setFill];
    [minuteHandPath fill];

    CGContextRestoreGState(context);





    //// 画出中间的圆圈
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* centreEmptyOvalPath = UIBezierPath.bezierPath;
    [centreEmptyOvalPath moveToPoint: CGPointMake(-4.42, -4.35)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-4.42, 4.33) controlPoint1: CGPointMake(-6.82, -1.95) controlPoint2: CGPointMake(-6.82, 1.93)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(4.26, 4.33) controlPoint1: CGPointMake(-2.02, 6.73) controlPoint2: CGPointMake(1.86, 6.73)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(4.26, -4.35) controlPoint1: CGPointMake(6.66, 1.93) controlPoint2: CGPointMake(6.66, -1.95)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-4.42, -4.35) controlPoint1: CGPointMake(1.86, -6.75) controlPoint2: CGPointMake(-2.02, -6.75)];
    [centreEmptyOvalPath closePath];
    [centreEmptyOvalPath moveToPoint: CGPointMake(7.78, -7.7)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(7.78, 7.85) controlPoint1: CGPointMake(12.08, -3.41) controlPoint2: CGPointMake(12.08, 3.56)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-7.77, 7.85) controlPoint1: CGPointMake(3.49, 12.15) controlPoint2: CGPointMake(-3.48, 12.15)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-7.77, -7.7) controlPoint1: CGPointMake(-12.07, 3.56) controlPoint2: CGPointMake(-12.07, -3.41)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(7.78, -7.7) controlPoint1: CGPointMake(-3.48, -12) controlPoint2: CGPointMake(3.49, -12)];
    [centreEmptyOvalPath closePath];
    [hourAndMinuteHandColor setFill];
    [centreEmptyOvalPath fill];

    CGContextRestoreGState(context);


    //// 画出“12”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text12Rect = CGRectMake(-10, -82, 21, 17);
    {
        NSString* textContent = @&quot;12&quot;;
        NSMutableParagraphStyle* text12Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text12Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text12FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text12Style};

        [textContent drawInRect: CGRectOffset(text12Rect, 0, (CGRectGetHeight(text12Rect) - [textContent boundingRectWithSize: text12Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text12FontAttributes context: nil].size.height) / 2) withAttributes: text12FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出“3”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text3Rect = CGRectMake(72, -9, 12, 17);
    {
        NSString* textContent = @&quot;3&quot;;
        NSMutableParagraphStyle* text3Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text3Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text3FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text3Style};

        [textContent drawInRect: CGRectOffset(text3Rect, 0, (CGRectGetHeight(text3Rect) - [textContent boundingRectWithSize: text3Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text3FontAttributes context: nil].size.height) / 2) withAttributes: text3FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出“6”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text6Rect = CGRectMake(-4, 65, 12, 17);
    {
        NSString* textContent = @&quot;6&quot;;
        NSMutableParagraphStyle* text6Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text6Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text6FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text6Style};

        [textContent drawInRect: CGRectOffset(text6Rect, 0, (CGRectGetHeight(text6Rect) - [textContent boundingRectWithSize: text6Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text6FontAttributes context: nil].size.height) / 2) withAttributes: text6FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出“9”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text9Rect = CGRectMake(-82, -8, 12, 17);
    {
        NSString* textContent = @&quot;9&quot;;
        NSMutableParagraphStyle* text9Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text9Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text9FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text9Style};

        [textContent drawInRect: CGRectOffset(text9Rect, 0, (CGRectGetHeight(text9Rect) - [textContent boundingRectWithSize: text9Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text9FontAttributes context: nil].size.height) / 2) withAttributes: text9FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出表盘刻度
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* markPath = UIBezierPath.bezierPath;
    [markPath moveToPoint: CGPointMake(-2, -85)];
    [markPath addLineToPoint: CGPointMake(2, -85)];
    [markPath addLineToPoint: CGPointMake(2, -93)];
    [markPath addLineToPoint: CGPointMake(-2, -93)];
    [markPath addLineToPoint: CGPointMake(-2, -85)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-1, 93)];
    [markPath addLineToPoint: CGPointMake(3, 93)];
    [markPath addLineToPoint: CGPointMake(3, 85)];
    [markPath addLineToPoint: CGPointMake(-1, 85)];
    [markPath addLineToPoint: CGPointMake(-1, 93)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-45, -72.15)];
    [markPath addLineToPoint: CGPointMake(-41.54, -74.15)];
    [markPath addLineToPoint: CGPointMake(-45.54, -81.08)];
    [markPath addLineToPoint: CGPointMake(-49, -79.08)];
    [markPath addLineToPoint: CGPointMake(-45, -72.15)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(44.87, 81.5)];
    [markPath addLineToPoint: CGPointMake(48.33, 79.5)];
    [markPath addLineToPoint: CGPointMake(44.33, 72.57)];
    [markPath addLineToPoint: CGPointMake(40.87, 74.57)];
    [markPath addLineToPoint: CGPointMake(44.87, 81.5)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-75.07, -40)];
    [markPath addLineToPoint: CGPointMake(-73.07, -43.46)];
    [markPath addLineToPoint: CGPointMake(-80, -47.46)];
    [markPath addLineToPoint: CGPointMake(-82, -44)];
    [markPath addLineToPoint: CGPointMake(-75.07, -40)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(79.58, 48.13)];
    [markPath addLineToPoint: CGPointMake(81.58, 44.67)];
    [markPath addLineToPoint: CGPointMake(74.65, 40.67)];
    [markPath addLineToPoint: CGPointMake(72.65, 44.13)];
    [markPath addLineToPoint: CGPointMake(79.58, 48.13)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-85, 2)];
    [markPath addLineToPoint: CGPointMake(-85, -2)];
    [markPath addLineToPoint: CGPointMake(-93, -2)];
    [markPath addLineToPoint: CGPointMake(-93, 2)];
    [markPath addLineToPoint: CGPointMake(-85, 2)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(93, 1)];
    [markPath addLineToPoint: CGPointMake(93, -3)];
    [markPath addLineToPoint: CGPointMake(85, -3)];
    [markPath addLineToPoint: CGPointMake(85, 1)];
    [markPath addLineToPoint: CGPointMake(93, 1)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-72.57, 44)];
    [markPath addLineToPoint: CGPointMake(-74.57, 40.54)];
    [markPath addLineToPoint: CGPointMake(-81.5, 44.54)];
    [markPath addLineToPoint: CGPointMake(-79.5, 48)];
    [markPath addLineToPoint: CGPointMake(-72.57, 44)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(81.08, -45.87)];
    [markPath addLineToPoint: CGPointMake(79.08, -49.33)];
    [markPath addLineToPoint: CGPointMake(72.15, -45.33)];
    [markPath addLineToPoint: CGPointMake(74.15, -41.87)];
    [markPath addLineToPoint: CGPointMake(81.08, -45.87)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-39.67, 75.07)];
    [markPath addLineToPoint: CGPointMake(-43.13, 73.07)];
    [markPath addLineToPoint: CGPointMake(-47.13, 80)];
    [markPath addLineToPoint: CGPointMake(-43.67, 82)];
    [markPath addLineToPoint: CGPointMake(-39.67, 75.07)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(48.46, -79.58)];
    [markPath addLineToPoint: CGPointMake(45, -81.58)];
    [markPath addLineToPoint: CGPointMake(41, -74.65)];
    [markPath addLineToPoint: CGPointMake(44.46, -72.65)];
    [markPath addLineToPoint: CGPointMake(48.46, -79.58)];
    [markPath closePath];
    [markColor setFill];
    [markPath fill];

    CGContextRestoreGState(context);
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xcode6.1 SDK8.1测试没问题！&lt;/p&gt;

&lt;p&gt;代码中已经有无比详细的注释，而且该控件简单地令人发指~ 我相信你看的懂得！&lt;/p&gt;

&lt;p&gt;我想肯定有同学已经排着队，准备好了板砖，鸡蛋什么的，“博主！你妹！说好的无比迅速敏捷地开发iOS超精美控件 哪里迅速哪里敏捷？说好的奇淫巧技呢？”&lt;/p&gt;

&lt;p&gt;都说心急吃不了热豆腐，我有说文章结束了么？文章只是出轨而已了……&lt;/p&gt;

&lt;h2 id=&quot;paintcode&quot;&gt;PaintCode&lt;/h2&gt;

&lt;p&gt;代码是写出来了， 但是在&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)drawRect:(CGRect)rect&lt;/code&gt;方法中一笔一笔的勾画出来，确实是累人~&lt;/p&gt;

&lt;p&gt;所以我要祭出这次文章的纯24K真大杀器——PaintCode&lt;/p&gt;

&lt;p&gt;图3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为何要称PaintCode为终极大杀器？因为它真的很凶！如果说我们刚刚的项目需要花2~3个小时才能完成 而有了PaintCode之后我们只需要10~20分钟！！！就问你怕不怕！！！&lt;/p&gt;

&lt;p&gt;售价$99的PaintCode用起来就是爽！&lt;/p&gt;

&lt;p&gt;我突然想起自己的一个故事，有一年上大学，父亲到车站来送我，临上车前，父亲叮嘱我等他一会儿他要过铁道对面要给我买点东西，说我一个人过日子会很艰难，我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩；他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪。怕他看见，也怕别人看见。我再向外看时，他已抱了一个黑塑料袋子往回走了。过铁道时，他先将塑料袋散放在地上，自己慢慢爬下，再抱起塑料袋走。到这边时，我赶紧去搀他。他和我走到车上，将塑料袋一股脑儿放在我的皮大衣上：“最新的全是外国的动作片、游戏、音乐光盘，好好照顾自己”，想起老父亲微薄的退休金，我就有点气愤：“爸，你怎么……”，父亲赶忙凑到我的耳边：“D版的，八国联军当年抢得钱是该要回来的”，我：“……”&lt;/p&gt;

&lt;p&gt;好了我的故事讲完了 你们应该知道怎么找PaintCode了额&lt;/p&gt;

&lt;p&gt;我么开始PaintCode之旅吧&lt;/p&gt;

&lt;p&gt;打开Paint&lt;/p&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就像PS一样只要你画的出，就能生成代码（支持swift哦）&lt;/p&gt;

&lt;p&gt;我们就试试画出DDClock来吧&lt;/p&gt;

&lt;p&gt;选中Oval&lt;/p&gt;

&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按住shift键拖出一个规则的圆形 ，填充颜色，这个就是代码中的rimPath&lt;/p&gt;

&lt;p&gt;图6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再次选中Oval，同样的方法在拖一个圆出来，&lt;/p&gt;

&lt;p&gt;图7&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个就是代码中的facePath。&lt;/p&gt;

&lt;p&gt;在PaintCode中尽量将所有的图形、颜色都自己取一个名字，比如我把第一个Oval取名字rim，第二个Oval取名字face&lt;/p&gt;

&lt;p&gt;这样表盘的边框和中间都出来了额，接下来就是表盘的刻度了&lt;/p&gt;

&lt;p&gt;选中rect&lt;/p&gt;

&lt;p&gt;图8&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拖出其中的一个小刻度&lt;/p&gt;

&lt;p&gt;图9&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后选中这个小刻度复制出另一个小刻度，放到第一个刻度的对面，就像这样&lt;/p&gt;

&lt;p&gt;图10&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后按住shift键 同时选中这两个小刻度，点击工具栏的Union&lt;/p&gt;

&lt;p&gt;图11&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样两个小刻度就成为了一个对象，这时点击右侧的Transforms，就会出现旋转图形的操作，把旋转中心（图12中绿色的瞄准星）拖到钟表的中心位置&lt;/p&gt;

&lt;p&gt;图12&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样设置Rotation的参数就可以围绕整个钟表旋转这个刻度了，所以马上同时复制这个刻度5份，分别操作旋转，让它们分别旋转30、60、90、120、150这样所有的刻度都出来了，然后再一次性的选中所有刻度Union一次，把所有刻度合并成一个图形。&lt;/p&gt;

&lt;p&gt;图13&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来就选中Text工具&lt;/p&gt;

&lt;p&gt;图14&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选中恰当的字体和大小，画出刻度值和上下午提示的AM/PM&lt;/p&gt;

&lt;p&gt;图15&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后是时针、分针和秒针了，做法是雷同的，聪明的你肯定知道该怎么做了，反正就是使用规则图形，通过Union、Intersection、Difference的操作产生不规则的图形&lt;/p&gt;

&lt;p&gt;图16&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图17&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图18&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-29-pic18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后看我的项目大体情况；&lt;/p&gt;

&lt;p&gt;到了这一步其实就可以直接复制代码走人就OK拉&lt;/p&gt;

&lt;p&gt;然后稍微写写项目的逻辑代码，测试，OK啦，是不是把2、3个小时的事情10分钟完成了？哈哈哈&lt;/p&gt;

&lt;p&gt;其实PaintCode的强大远不止于此，里面的Variables的功能，可以将图形中的某个值设置成变量，比如代码中的hourAngle、 minuteAngle 、 secondAngle 等，DDClock目前的大小的是固定的200x200，其实使用Variables添加scale的变量，还可以动态的修改所有图形的大小！当然还有Frame的使用啦……&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;对于PaintCode博主也只是浅尝而止，更多强大的功能，同学们还是自己挖掘吧。&lt;/p&gt;

&lt;p&gt;这里附上官网的&lt;a href=&quot;http://www.paintcodeapp.com/&quot; target=&quot;_blank&quot;&gt;地址&lt;/a&gt;，PaintCode 里面有视频教程，文档等（视频是油管网的，所以需要爬梯子，呵呵，你懂的）&lt;/p&gt;

&lt;p&gt;这里也附上我写的项目源代码 &lt;a href=&quot;https://github.com/daiweilai/DDClock&quot; target=&quot;_blank&quot;&gt;DDClock&lt;/a&gt;（尼玛！github使用代理比直接访问更快，你能忍？）&lt;/p&gt;

&lt;p&gt;这个礼拜，完成了毕设的主题和一些细节，大概是设计一套移动客户端和后台服务器安全交互的方案，涉及到各种安全通信，可靠性传输，内容加解密等内容，我会把这个设想写到博客上的；&lt;/p&gt;

&lt;p&gt;女朋友回老家了，剩下自己一个人撸啊撸T_T;&lt;/p&gt;

&lt;p&gt;天杀的12306买了两天都没买到回家的票，明明买不到票，却还要写着有余票，哎，最后我决定坐头等舱回家了~&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/01/29/%E6%97%A0%E6%AF%94%E8%BF%85%E9%80%9F%E6%95%8F%E6%8D%B7%E5%9C%B0%E5%BC%80%E5%8F%91iOS%E8%B6%85%E7%B2%BE%E7%BE%8E%E6%8E%A7%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/01/29/%E6%97%A0%E6%AF%94%E8%BF%85%E9%80%9F%E6%95%8F%E6%8D%B7%E5%9C%B0%E5%BC%80%E5%8F%91iOS%E8%B6%85%E7%B2%BE%E7%BE%8E%E6%8E%A7%E4%BB%B6/</guid>
        
        <category>奇巧集</category>
        
        <category>PaintCode</category>
        
        
      </item>
    
      <item>
        <title>iOS中的预编译指令</title>
        <description>&lt;h1 id=&quot;ios中的预编译指令的初步探究&quot;&gt;iOS中的预编译指令的初步探究&lt;/h1&gt;

&lt;h2 id=&quot;开篇&quot;&gt;开篇&lt;/h2&gt;

&lt;p&gt;我们人类创造东西的时候有个词叫做”仿生学“！人类创造什么东西都会模仿自己来创造，所以上帝没有长成树的样子而和人长得一样，科幻片里面外星人也像人一样有眼睛有鼻子……但是人类自己创造的东西如果太像自己，自己又会吓尿(恐怖谷效应)，人类真是奇葩；奇葩的我们在20世纪创造了改变世界的东西——计算机(电脑)，不用怀疑，这货当然也是仿生学！这货哪里长得像人了？？别不服，先听我说完，先把你的砖头放下。狭义的仿生学是外形上仿生嘛，其实广义上仿生学还可以原理的仿生，构造的仿生，性能的仿生阿拉巴拉……，计算机(这里我狭义的使用个人PC来举例)我们常说的有输入设备(键盘呀鼠标呀摄像头呀……)、处理设备(CPU、GPU……)和输出设备(显示器、音响……);然后你自个儿瞅瞅你自己的眼睛耳朵(输入),大脑(处理),四肢(输出) 当初设计电脑必须要这种构造的人难道不是瞅着自己来设计计算机的么？^_^&lt;/p&gt;

&lt;p&gt;所以上计算机组成原理的时候有什么地方晦涩难以理解的时候，我就立刻解禁我高中的生物知识，然后就迎刃而解了~但是今天我这篇博客是要讲程序的呀，这把犊子扯的那么远看客们也难免心有愤懑，你切勿急躁，我马上就带你们飞！跟着我用仿生学的角度去理解计算机，那么计算机程序是神马呢？教科书上怎么说？可以被计算机执行，那神马东西会被人执行的呢？老婆的命令、老爸的呵斥、项目经理的需求变更……我们都会执行，貌似这就是人的程序了，这确实就是人的程序！下面我具体拿老婆的命令来详解一下人得程序的执行过程；比如老婆说了一句”你给我滚出去睡沙发！“，首先这句话的处理流程是这样的：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;带你们看计算机程序执行过程之前，我们要严肃的了解一点程序的编译，也就是上图中的，我们把老婆的命令转换成电信号的过程。在计算机世界中有些好事者把这个玩意儿称作编译器(compiler)，什么gcc呀clang呀阿拉巴拉，说的编译器这名字逼格好高~其实说白了就是个翻译的东西，如我们人执行程序过程中，把老婆的话(也是人类的话)翻译成大脑懂的话(电波)，在计算机中就是把各种编程语言(c、c++、oc……)翻译成0101011……让计算机懂。编译器的工作原理基本上都是三段式的，可以分为前端（Frontend）、优化器（Optimizer）、后端（Backend）。前端负责解析源代码，检查语法错误，并将其翻译为抽象的语法树（Abstract Syntax Tree）。优化器对这一中间代码进行优化，试图使代码更高效。后端则负责将优化器优化后的中间代码转换为目标机器的代码，这一过程后端会最大化的利用目标机器的特殊指令，以提高代码的性能。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么要弄成这三段式的呢？我肯定不会从什么框架、结构啊优化……角度说起，因为我也不懂呀，哈哈 不过我可以讲一个过去的故事给大家，大家试想一下编译器是怎么开发出来的呀，好家伙，上网一搜LLVM编译器是C++写的，那c++的编译器呢？其实不用那么麻烦，现在把你的手借给我，让我牵着你回到上个世纪70年代，里奇正在为他新发明的C语言在写编译器呢，他在用汇编语言！汇编语言怎么编译变成二进制流呢？答案是使用01011机器码编写的编译器；所以编译器和计算机语言的进步就像这样迭代发展的，再之后是用高级语言写更高级的编译器，高级的编译器能编译更高级的计算机语言……，虽然蓝翔的挖掘机技术强，但问题还是来了，世界上计算机那么多，各种不同的架构，人还好基本架构都一样，但是计算机有Intel架构的又有ARM架构，怎么能让编程语言通过编译分别产生不同架构的执行码呢？所以这就是编译器三段式这种模型的好处了，当我们要支持多种语言时，只需要添加多个前端就可以了。当需要支持多种目标机器时，只需要添加多个后端就可以了。对于中间的优化器，我们可以使用通用的中间代码。gcc可以支持c、c++、java……等语言的编译。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图3&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么一个HelloWord的程序的编译和执行过程大家就按照图1自行脑补吧&lt;/p&gt;

&lt;p&gt;说了这么多终于正片开始了~ 原来我的啰嗦，因为我就是叫做话痨戴^_^，本人从没有开发过Mac os的应用所以本文主要示例代码和框架都是iOS下的，但是是因为C系语言的预编译指令，所以基本都能通用。虽然这篇文章有个宏大的开端，但是本文主要就是想探究一下编译过程中的预处理部分的部分预处理指令，希望本文能够做到的就是抛砖引玉，给比我菜的广大猿友指引一条学习的方向。&lt;/p&gt;

&lt;p&gt;在很久很久以前的Xcode不知道什么版本，Build settings里面还可以选择不同的编译器。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图4&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同的编译器，是否对于预处理指令有差异，我也没办法考究了。还有其实、其实人家接触iOS也只有3个月，我开发iOS使用的第一个IDE就是XCode6，如果坑了大家，那就索瑞~~&lt;/p&gt;

&lt;p&gt;现在Xcode6里面默认使用了Apple LLVM(Low Level Virtual Machine) 6.0的编译器&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图5&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;各种编译器的区别还有几本对比知识可以参看&lt;a href=&quot;http://www.cnblogs.com/zuopeng/p/4141467.html&quot; target=&quot;_blank&quot;&gt;LLVM和GCC的区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于苹果的和gcc以及LLVM背后激情个故事看以看这个&lt;a href=&quot;http://history.programmer.com.cn/9436/&quot; target=&quot;_blank&quot;&gt;三好学生Chris Lattner的LLVM编译工具链&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么接下来就是正片的高潮啦——预处理指令&lt;/p&gt;

&lt;p&gt;高潮之前再加一个预高潮^_^，干嘛要预处理呢？回去看图一，老婆说“你给我滚出去睡沙发！” 如果你没有预处理，你按照顺序运行，先滚出去了你可能还不想睡觉，你在沙发上看电视看了几个小时后才打算睡觉，这时候你发现你竟然忘了从房间拿枕头和被子出来了，你这时候就去敲老婆的门，又是一顿臭骂，之后你才能睡觉……折腾不？ 如果你进行了预处理，当老婆说完指令，其中你获取到关键字“睡沙发”，不管我滚出去之后睡不睡觉，我都先从房间把被子枕头拿到沙发，这样是不是效率高了很多？同样对于C系的语言的开发，预处理可谓举足轻重，如果你阅读过优秀的C源代码，你一定看到了很多 #define #if #error ……  预编译对程序之后的编译提供了很多方便以及优化，对于错误处理、包引用、跨平台……有着极大的帮助。而且开发中使用预编译指令完成一些事情也是很屌的事情，并且你既然走上了一条改变世界的道路那么当一个有逼格的程序猿的觉悟也需要觉醒呀&lt;/p&gt;

&lt;h2 id=&quot;文件包含&quot;&gt;文件包含&lt;/h2&gt;

&lt;h3 id=&quot;include&quot;&gt;#include&lt;/h3&gt;

&lt;p&gt;这个我真的不想多说，只要你大学C语言课程不是体育老师教得话，他们肯定跟你说过#include “”、#include &amp;lt;&amp;gt;的区别，他们肯定说过#include“xxx”包含和使用#include &lt;xxx&gt;包含的不同之处就是使用&amp;lt;&amp;gt;包含时，预处理器会搜索C函数库头文件路径下的文件，而使用“”包含时首先搜索程序所在目录，其次搜索系统Path定义目录，如果还是找不到才会搜索C函数库头文件所在目录。&lt;/xxx&gt;&lt;/p&gt;

&lt;p&gt;所以我不想为了弥补你老师犯下的错，我就不想重复了，有一点需要注意使用#include的时候包含文件的时候是不能递归包含的，例如a.h文件包含b.h，而b.h就不能再包含a.h了；还有就是重复包含(比如a.h包含了b.h,然后main.c中又包含了a.h和b.h)虽然是允许的但是这会降低编译性能。那该怎么办呢？1、使用#import替代include 2、使用宏判断(宏判断下面会详解)，xcode很聪明，只要新建一个头文件a.h 里面就自动就生成了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图6&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个看不懂？你可以等看完#ifndef和#define之后就明白了，大概的原理就是，用宏定义判断一个宏是否定义了，如果没有定义则会定义这个宏，这样以来如果已经包含过则这个宏定义肯定已经定义过了，即使再包含也不会重新定义了，下面的代码也就不会包含进去。&lt;/p&gt;

&lt;p&gt;这个是非C标准库里面的预处理指令，但是Xcode中允许使用，所以也就介绍一下吧。#include_next是GNU(一群牛逼的人疯狂开源的组织，可以说是Linux的灵魂)的一个扩展，并不是标准C中的指令 例如有个搜索路径链，在#include中，它们的搜索顺序依次是A，B，C，D和E。在B目录中有个头文件叫a.h，在D目录中也有个头文件叫a.h，如果在我们的源代码中这样写#include &lt;a.h&gt;，那么我们就会包含的是B目录中的a.h头文件，如果我们这样写#include_next &lt;a.h&gt;那么我们就会包含的是D目录中的a.h头文件。#include_next &lt;a.h&gt;的意思按我们上面的引号包含中的解释来说就是“在B目录中的a.h头文件后面的目录路径（即C，D和E）中搜索a.h头文件并包含进来）。#include_next &lt;a.h&gt;的操作会是这样的，它将在A，B，C，D和E目录中依次搜索a.h头文件，那么首先它会在B目录中搜索到a.h头文件，那它就会以B目录作为分割点，搜索B目录后面的目录（C，D和E），然后在这后面的目录中搜索a.h头文件，并把在这之后搜索到的a.h头文件包含进来。这样说的话大家应该清楚了吧。&lt;/a.h&gt;&lt;/a.h&gt;&lt;/a.h&gt;&lt;/a.h&gt;&lt;/p&gt;

&lt;h3 id=&quot;import&quot;&gt;#import&lt;/h3&gt;

&lt;p&gt;OC特有的就是一个智能的#include，解决了#include的重复包含的问题。&lt;/p&gt;

&lt;h2 id=&quot;宏定义&quot;&gt;宏定义&lt;/h2&gt;

&lt;h3 id=&quot;define&quot;&gt;#define&lt;/h3&gt;

&lt;p&gt;这个使用的就太多了，个人认为是所有预处理指令中最酷的！必须要学习！这里我厚颜无耻的转载OneV’s Den(喵神)的文章，他写的非常的棒！&lt;a href=&quot;http://www.onevcat.com/2014/01/black-magic-in-macro/&quot; target=&quot;_blank&quot;&gt;宏定义的黑魔法 - 宏菜鸟起飞手册&lt;/a&gt;，请叫我快乐的搬运工！&lt;/p&gt;

&lt;p&gt;附上那头小牛&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
#define NSLog(format, ...)   fprintf(stderr, &quot;&amp;lt;%s : %d&amp;gt; %s\n&quot;,                                           \

[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \

__LINE__, __func__);                                                        \

(NSLog)((format), ##__VA_ARGS__);                                           \

fprintf(stderr, &quot;\n ------------------\n/ Hello David Day! \\\n\\ my Macro Log ~   /\n ------------------\n            \\\n             \\   ^__^\n                 (OO)\__________\n                 (__)\\          )\\/\\\n                     ||_______ _)\n                     ||       W |\n       YYy           ww        ww\n&quot;);



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;图9&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;undef&quot;&gt;#undef&lt;/h3&gt;

&lt;p&gt;当你使用了#define宏定义后，则在整个程序的运行周期内这个宏都是有效的，但有时候我们在某个逻辑里希望这个宏失效不想使用，则会使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#define NetworkOn //定义一个宏，如果该宏定义了，则在应用里使用网络

-(void)closeNetwork{//突然发生意外的情况，网络无法使用了，调用该方法，取消NetworkOn的宏定义
#undef NetworkOn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;条件编译&quot;&gt;条件编译&lt;/h2&gt;

&lt;h3 id=&quot;if-else-endif&quot;&gt;#if #else #endif&lt;/h3&gt;

&lt;p&gt;if就和我们常用的条件语句的if使用方式一样，#if的后面跟上条件表达式，后面跟上一个#endif表示结束#if，虽说这玩意儿简单，但是用的好，对于某些取巧的工作特别容易实现。比如你现在有这样的需求，我的程序平时调试模式的时候需要打印一些log，但是发布模式的应用就不用再打印log了，怎么办？很多人就说发布的时候吧log语句一句一句的删除呗~ 那客户发烂咋说你写的东西是狗屎让你修改，所以你又要回来调试，当你调试的时候你菊花肯定一紧,以前的调试语句因为过于自信在发布的时候全都删除了，又想不到发布后又被要求修改~，有基友就说了，那就不删除log语句呗，反正是打印到控制台的信息，用户又看不到~，果然没有安全意识，企业开发不是学雷锋，不用把你的所有log都写在日记本，有时候你的软件被破解的原因就是因为你的调试信息出卖了你。安全意识不可无，不然老王替你生孩子~~~~~。&lt;/p&gt;

&lt;p&gt;怎么做呢？&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//swift语言&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if DEBUG &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;DEBUG是xcode的预定义的宏，这个东西多的很呢，要慢慢挖掘呢。 以后打印log你都只使用dlog()这个函数，如果你是在调试模式的时候就会打印，否则就不会打印了。&lt;/p&gt;

&lt;p&gt;其他例子：&lt;/p&gt;

&lt;p&gt;判断是否开启ARC，有些库需要ARC支持，则在编译之前可以判断用户有没有开启ARC&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#if !__has_feature(objc_arc)
//如果没有开启ARC这里可以做一些错误处理 比如：
#error &quot;啊 啊 啊~ 伦家需要ARC&quot;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样__has_feature(objc_arc)这玩意儿也是xcode预置的 ， 前缀是这个的”__“都是预定宏；&lt;/p&gt;

&lt;p&gt;又比如，对不同版本的os系统做策略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &amp;lt; __IPHONE_7_0
//如果iOS版本低于7.0，这里可以干一些事情
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又或者判断设备类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
#if IS_IPAD
//这台设备是IPAD呀~~~~
#else
//这货是IPhone
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个东西简单但是很常使用，正所谓IF在手，天下我有 哈哈哈&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt; #if define  #ifdef  #ifndef  #elif
　　#if define = #ifdef

　　#if !define = #ifndef

　　#elif = &quot;else if&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;错误警告处理&quot;&gt;错误、警告处理&lt;/h2&gt;

&lt;h3 id=&quot;error&quot;&gt;#error&lt;/h3&gt;

&lt;p&gt;如果编译器遇到这货，马上就会罢工。再说Xcode的错误纠正功能这么强大，所以几乎不可能在编译过程中遇到#error了，所以说这货没用？非也~，我们是受过高等教育的高材生，我们要懂得辩证观点还要了解价值定理！任何事物都有存在的价值的。虽说今天的IDE很好很强大，#error似乎没什么用了~但是还有有一群猿类孤高冷傲，隐居山林，他们鄙视一切IDE，他们坚信Notepad就是他们的屠龙宝刀……&lt;/p&gt;

&lt;p&gt;对于这些虚幻飘渺的程序猿们，他们还是需要#error来给他们预报编译前的错误的。我们说点有价值的，如果非要用#error，那在我们当下的开发中怎么用？&lt;/p&gt;

&lt;p&gt;现在#error还是有用的，尤其是你在开发一个库的时候，这个库的使用需要一定的条件，如果不满足这个条件，你就不让使用者编译。这样不就可以使用#error啦嘛&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#if !__has_feature(objc_arc)
#error &quot;我的低调不是你装逼的资本！这个库需要开启ARC，不然你别用！&quot;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如果用户没有开启ARC就无法进行编译了，因为xcode看到#error就不编译了，在这里只有开启了ARC，#error才会不见。&lt;/p&gt;

&lt;h3 id=&quot;warning&quot;&gt;#warning&lt;/h3&gt;

&lt;p&gt;这个用法很简单，只要后面跟上你想警告的话就OK了，这样你就可以让编译器提醒这个警告。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图10&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你在Xcode中设置了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图11&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你设置成Yes，那么你的waring就等于error，编译不了的哦。&lt;/p&gt;

&lt;p&gt;请再次叫我快乐的小搬运工~ 又是他 —-&amp;gt;Onev’s Den写的东西，我就是喜欢他，怎么样怎么样？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://onevcat.com/2013/05/talk-about-warning/&quot; target=&quot;_blank&quot;&gt;谈谈Objective-C的警告&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;编译器控制&quot;&gt;编译器控制&lt;/h2&gt;

&lt;h3 id=&quot;pragma&quot;&gt;#pragma&lt;/h3&gt;

&lt;p&gt;大家都说在所有的预处理指令中，#Pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，给出主机或操作系统专有的特征。依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的。&lt;/p&gt;

&lt;p&gt;其格式一般为: #pragma Para。其中Para 为参数&lt;/p&gt;

&lt;p&gt;我们就说说iOS下，常用的&lt;/p&gt;

&lt;h3 id=&quot;pragma-mark&quot;&gt;#pragma mark&lt;/h3&gt;

&lt;p&gt;如果一个文件代码量很大，有时候找某段逻辑不太好找，你就可以使用#pragma mark！&lt;/p&gt;

&lt;p&gt;比如这样：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图12&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图13&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在方法导航哪里就会出现你的mark了 是不是很方便呀&lt;/p&gt;

&lt;p&gt;如果使用了 “#pragma mark -“ 如这样：&lt;/p&gt;

&lt;h3 id=&quot;pragma-mark--&quot;&gt;#pragma mark -&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#pragma mark -
#pragma mark 这里是applicationWillTerminate方法呀~
- (void)applicationWillTerminate:(UIApplication *)application {
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会这样，&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图14&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://daiweilai.github.io/img/post/2015-1-20-pic14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;自动分隔开了！！！&lt;/p&gt;

&lt;h3 id=&quot;pragma-message&quot;&gt;#pragma message(“”)&lt;/h3&gt;

&lt;p&gt;可以输出调试信息&lt;/p&gt;

&lt;p&gt;控制编译器行为不过多解释了&lt;/p&gt;

&lt;h3 id=&quot;pragma-clang-diagnostic-push&quot;&gt;#pragma clang diagnostic push&lt;/h3&gt;

&lt;h3 id=&quot;pragma-clang-diagnostic-ignored-clang的参数&quot;&gt;#pragma clang diagnostic ignored “clang的参数”&lt;/h3&gt;

&lt;h3 id=&quot;pragma-clang-diagnostic-pop&quot;&gt;#pragma clang diagnostic pop&lt;/h3&gt;

&lt;p&gt;自行&lt;a href=&quot;http://clang.llvm.org/get_started.html&quot; target=&quot;_blank&quot;&gt;Clang使用手册&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;pragma非常复杂需要你对编译器底层非常的了解，只有当你开发一些比较底层的framework的时候才可能比较多用的，我是初学者，我不用我怕谁？&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;h3 id=&quot;line&quot;&gt;#line&lt;/h3&gt;

&lt;p&gt;在说这个东西的时候我们先来看一个预定义的宏，&lt;strong&gt;LINE&lt;/strong&gt;，我们在《宏定义的黑魔法 - 宏菜鸟起飞手册》自定义NSLog中见过吧&lt;/p&gt;

&lt;p&gt;C语言中的__LINE__用以指示本行语句在源文件中的位置信息。而#line就是可以改变当前行的行号在编译器中的表示，并且之后的行号也会相应的改变，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;1 #include &amp;lt;stdio.h&amp;gt;
2 main(){
3     printf(&quot;%d\n&quot;,LINE);
4 #line 100  //指定下一行的LINE为100
5     printf(&quot;%d\n&quot;,LINE);
6     printf(&quot;%d\n&quot;,LINE);
7     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;3
100
101
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;　　这篇文章完了~ 这篇文章既是我学习的笔记也是我思考的感悟和一些技术资料的集合，我很用心的写，白天上班写代码，晚上要准备本科的毕业设计，周末陪女朋友，所以我只有在拉屎蹲坑的时候一点一点写出来的，其中一定错漏百出，所以希望看到文章的朋友尽情的喷！砖头不要省！反正我都写代码了我还怕谁？&lt;/p&gt;

&lt;p&gt;　　但是最终嘛，我还是希望能帮到刚刚开始学习的朋友们，毕竟你丫的写的代码太差，也是在污染环境呀！！不是开玩笑！不单单污染环境，你还破坏世界和平，如果你的代码效率很差，你想想如果你的代码运行在电脑上或者手机上那么是不是很费电？费电了是不是要烧很多煤炭来发电？大气中的有害气体是不是越来越多了？温室效应，臭氧层破坏，土地沙漠化，北京沙尘暴，拿钱治理，钱，贪污，腐败，革命，美国参战，朝鲜怒点核武……都怪你！！知道了吧。&lt;/p&gt;

&lt;p&gt;　　还有哦，转载不注明！BUG一生随。你自己看着办&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写代码就是在维护世界和平，谢谢 @戴伟来&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 20 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/</guid>
        
        <category>基础整理</category>
        
        <category>预编译</category>
        
        <category>宏定义</category>
        
        
      </item>
    
  </channel>
</rss>
